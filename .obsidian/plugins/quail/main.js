/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/modals/utils.ts
function constructModalTitle(container, text) {
  const title = container.createEl("h2", {
    text
  });
  Object.assign(title.style, {
    margin: "0 0 1rem 0",
    fontSize: "1.1rem",
    fontWeight: "bold",
    textAlign: "center"
  });
  return title;
}
var init_utils = __esm({
  "src/modals/utils.ts"() {
  }
});

// src/i18n/lang/en.json
var en_default;
var init_en = __esm({
  "src/i18n/lang/en.json"() {
    en_default = {
      "common.ok": "OK",
      "common.cancel": "Cancel",
      "common.close": "Close",
      "common.login": "Login",
      "common.logout": "Logout",
      "common.copied": "Copied",
      "common.generate": "Generate",
      "error_modal.title": "Oooops, something went wrong",
      "error_modal.error_message": "Error Message",
      "error_modal.copy": "Copy message",
      "message_modal.title": "A Message from Quaily",
      "preview_modal.title": "Preview Your Post",
      "preview_modal.hint": "Preview will be expired in 10 minutes. Don't share the link with others.",
      "preview_modal.mobile.title": "\u{1F4F1} Preview on mobile",
      "preview_modal.mobile.desc": "Scan the QRcode to preview on the mobile device",
      "preview_modal.desktop.title": "\u{1F4BB} Preview on desktop",
      "preview_modal.desktop.desc": "Click to preview in the browser",
      "preview_modal.preview": "Preview",
      "publish_result_modal.title": "\u{1F389} Successfully Published!",
      "publish_result_modal.copy_link": "Copy link",
      "publish_result_modal.visit_post": "View Post",
      "loading_modal.text.loading": "Loading",
      "loading_modal.text.still_loading": "Still loading",
      "loading_modal.text.almost_there": "Almost there",
      "loading_modal.text.just_a_moment": "Just a moment",
      "loading_modal.text.working_on_it": "Working on it",
      "message_modal.failed_to_verify_meta.title": "Failed to verify the metadata",
      "message_modal.metadata_exists.title": "Metadata already exists",
      "message_modal.metadata_exists.desc": "Please edit manually or use AI to generate it",
      "message_modal.send_post.title": "Sending by Quaily",
      "message_modal.send_post.desc": "This post has been added into the sending queue. It may take a few minutes to send out.",
      "message_modal.no_channels_found.title": "No Channel",
      "message_modal.no_channels_found.desc": "Please create a channel at first.",
      "notices.post_saved": "\u2705 Post saved!",
      "notices.set_channel_success": "\u2705 {title} is the default channel.",
      "notices.unpublish_success": "\u{1F4D5} This post has been unpublished. No more visible to readers.",
      "actions.ai_gen_metadata": "Generate metadata by AI",
      "actions.send": "Send",
      "actions.save": "Save",
      "actions.publish": "Publish",
      "actions.unpublish": "Unpublish",
      "actions.insert_metadata": "Insert metadata template",
      "actions.preview": "Preview",
      "actions.set_channel": "Set default channel",
      "actions.set_channel.select_channel": "Select a channel",
      "settings.account.logged.title": "Hello, {name}",
      "settings.account.logged.desc": "You are logged in as {email}",
      "settings.account.need_to_login.title": "Login to Quaily",
      "settings.account.need_to_login.desc": "Please login to use the plugin",
      "settings.channel.title": "Channel",
      "settings.channel.desc": "Select the channel you want to use",
      "settings.channel.create": "Create a channel",
      "settings.channel.empty": "No channel",
      "settings.behavior.use_english_cmds.title": "Use English commands",
      "settings.behavior.use_english_cmds.desc": "Keep using English version commands in obsidian command palette (require to restart the plugin)",
      "settings.behavior": "Behavior",
      "settings.behavior.use_first_image_as_cover.title": "Use the first image as post cover",
      "settings.behavior.use_first_image_as_cover.desc": "If the post cover is empty, the first image in the post will be used",
      "settings.editor": "Editor",
      "settings.editor.strict_line_breaks.title": "Strict line breaks",
      "settings.editor.strict_line_breaks.desc": "Markdown specs ignore single line breaks. If you want to keep them, enable this option."
    };
  }
});

// src/i18n/lang/ja.json
var ja_default;
var init_ja = __esm({
  "src/i18n/lang/ja.json"() {
    ja_default = {
      "actions.ai_gen_metadata": "AI\u306B\u3088\u308B\u30E1\u30BF\u306E\u751F\u6210",
      "actions.insert_metadata": "\u30E1\u30BF\u30C7\u30FC\u30BF\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8\u3092\u633F\u5165",
      "actions.preview": "\u30D7\u30EC\u30D3\u30E5\u30FC",
      "actions.publish": "\u516C\u958B",
      "actions.save": "\u4FDD\u5B58",
      "actions.send": "\u9001\u308B",
      "actions.set_channel": "\u30C7\u30D5\u30A9\u30EB\u30C8\u30C1\u30E3\u30F3\u30CD\u30EB\u3092\u8A2D\u5B9A",
      "actions.set_channel.select_channel": "\u30C1\u30E3\u30F3\u30CD\u30EB\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
      "actions.unpublish": "\u975E\u516C\u958B",
      "common.cancel": "\u30AD\u30E3\u30F3\u30BB\u30EB",
      "common.close": "\u9589\u3058\u308B",
      "common.copied": "\u30B3\u30D4\u30FC\u3055\u308C\u307E\u3057\u305F",
      "common.generate": "\u751F\u6210",
      "common.login": "\u30ED\u30B0\u30A4\u30F3",
      "common.logout": "\u30ED\u30B0\u30A2\u30A6\u30C8",
      "common.ok": "OK",
      "error_modal.copy": "\u30E1\u30C3\u30BB\u30FC\u30B8\u3092\u30B3\u30D4\u30FC",
      "error_modal.error_message": "\u30A8\u30E9\u30FC\u30E1\u30C3\u30BB\u30FC\u30B8",
      "error_modal.title": "\u304A\u3063\u3068\u3001\u4F55\u304B\u304C\u3046\u307E\u304F\u3044\u304B\u306A\u304B\u3063\u305F\u3088",
      "loading_modal.text.almost_there": "\u3082\u3046\u5C11\u3057\u3067\u5230\u7740\u3057\u307E\u3059\u3002",
      "loading_modal.text.just_a_moment": "\u3061\u3087\u3063\u3068\u5F85\u3063\u3066\u304F\u3060\u3055\u3044\u3002",
      "loading_modal.text.loading": "\u30ED\u30FC\u30C7\u30A3\u30F3\u30B0",
      "loading_modal.text.still_loading": "\u307E\u3060\u8AAD\u307F\u8FBC\u307F\u4E2D",
      "loading_modal.text.working_on_it": "\u53D6\u308A\u7D44\u3093\u3067\u3044\u307E\u3059",
      "message_modal.failed_to_verify_meta.title": "\u30E1\u30BF\u30C7\u30FC\u30BF\u306E\u691C\u8A3C\u306B\u5931\u6557\u3057\u307E\u3057\u305F\u3002",
      "message_modal.metadata_exists.desc": "\u624B\u52D5\u3067\u7DE8\u96C6\u3059\u308B\u304B\u3001AI\u3092\u4F7F\u7528\u3057\u3066\u751F\u6210\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
      "message_modal.metadata_exists.title": "\u30E1\u30BF\u30C7\u30FC\u30BF\u306F\u3059\u3067\u306B\u5B58\u5728\u3057\u307E\u3059\u3002",
      "message_modal.no_channels_found.desc": "\u6700\u521D\u306B\u30C1\u30E3\u30F3\u30CD\u30EB\u3092\u4F5C\u6210\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
      "message_modal.no_channels_found.title": "\u30C1\u30E3\u30F3\u30CD\u30EB\u306A\u3057",
      "message_modal.send_post.desc": "\u3053\u306E\u8A18\u4E8B\u306F\u9001\u4FE1\u30AD\u30E5\u30FC\u306B\u8FFD\u52A0\u3055\u308C\u307E\u3057\u305F\u3002\u9001\u4FE1\u306B\u306F\u6570\u5206\u304B\u304B\u308B\u5834\u5408\u304C\u3042\u308A\u307E\u3059\u3002",
      "message_modal.send_post.title": "\u30AF\u30A8\u30A4\u30EA\u30FC\u306B\u3088\u308B\u9001\u4FE1",
      "message_modal.title": "\u30AF\u30A8\u30A4\u30EA\u30FC\u304B\u3089\u306E\u30E1\u30C3\u30BB\u30FC\u30B8",
      "notices.post_saved": "\u8A18\u4E8B\u304C\u4FDD\u5B58\u3055\u308C\u307E\u3057\u305F\uFF01",
      "notices.set_channel_success": "\u2705 {title} \u306F\u30C7\u30D5\u30A9\u30EB\u30C8\u30C1\u30E3\u30F3\u30CD\u30EB\u3067\u3059\u3002",
      "notices.unpublish_success": "\u3053\u306E\u8A18\u4E8B\u306F\u975E\u516C\u958B\u306B\u306A\u308A\u307E\u3057\u305F\u3002\u8AAD\u8005\u306B\u306F\u3082\u3046\u8868\u793A\u3055\u308C\u307E\u305B\u3093\u3002",
      "preview_modal.desktop.desc": "\u30D6\u30E9\u30A6\u30B6\u3067\u30D7\u30EC\u30D3\u30E5\u30FC\u3059\u308B\u306B\u306F\u30AF\u30EA\u30C3\u30AF\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
      "preview_modal.desktop.title": "\u{1F4BB} \u30C7\u30B9\u30AF\u30C8\u30C3\u30D7\u3067\u306E\u30D7\u30EC\u30D3\u30E5\u30FC",
      "preview_modal.hint": "10\u5206\u5F8C\u306B\u30D7\u30EC\u30D3\u30E5\u30FC\u304C\u671F\u9650\u5207\u308C\u306B\u306A\u308A\u307E\u3059\u3002\u4ED6\u306E\u4EBA\u3068\u30EA\u30F3\u30AF\u3092\u5171\u6709\u3057\u306A\u3044\u3067\u304F\u3060\u3055\u3044\u3002",
      "preview_modal.mobile.desc": "\u30E2\u30D0\u30A4\u30EB\u30C7\u30D0\u30A4\u30B9\u3067\u30D7\u30EC\u30D3\u30E5\u30FC\u3059\u308B\u306B\u306FQR\u30B3\u30FC\u30C9\u3092\u30B9\u30AD\u30E3\u30F3\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
      "preview_modal.mobile.title": "\u{1F4F1} \u30E2\u30D0\u30A4\u30EB\u3067\u306E\u30D7\u30EC\u30D3\u30E5\u30FC",
      "preview_modal.preview": "\u30D7\u30EC\u30D3\u30E5\u30FC",
      "preview_modal.title": "\u8A18\u4E8B\u3092\u30D7\u30EC\u30D3\u30E5\u30FC",
      "publish_result_modal.copy_link": "\u30EA\u30F3\u30AF\u3092\u30B3\u30D4\u30FC",
      "publish_result_modal.title": "\u{1F389} \u6210\u529F\u7684\u306B\u516C\u958B\u3055\u308C\u307E\u3057\u305F\uFF01",
      "publish_result_modal.visit_post": "\u8A18\u4E8B\u3092\u898B\u308B",
      "settings.account.logged.desc": "{email}\u3068\u3057\u3066\u30ED\u30B0\u30A4\u30F3\u3057\u3066\u3044\u307E\u3059",
      "settings.account.logged.title": "\u3053\u3093\u306B\u3061\u306F\u3001{name}",
      "settings.account.need_to_login.desc": "\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u4F7F\u7528\u3059\u308B\u306B\u306F\u30ED\u30B0\u30A4\u30F3\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
      "settings.account.need_to_login.title": "Quaily\u306B\u30ED\u30B0\u30A4\u30F3",
      "settings.behavior": "\u52D5\u4F5C",
      "settings.behavior.use_english_cmds.desc": "\u30AA\u30D6\u30B7\u30C7\u30A3\u30A2\u30F3\u30B3\u30DE\u30F3\u30C9\u30D1\u30EC\u30C3\u30C8\u3067\u82F1\u8A9E\u7248\u30B3\u30DE\u30F3\u30C9\u3092\u5F15\u304D\u7D9A\u304D\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044\uFF08\u30D7\u30E9\u30B0\u30A4\u30F3\u3092\u518D\u8D77\u52D5\u3059\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\uFF09",
      "settings.behavior.use_english_cmds.title": "\u82F1\u8A9E\u306E\u30B3\u30DE\u30F3\u30C9\u3092\u4F7F\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
      "settings.behavior.use_first_image_as_cover.desc": "\u6295\u7A3F\u306E\u30AB\u30D0\u30FC\u304C\u7A7A\u306E\u5834\u5408\u3001\u6700\u521D\u306E\u753B\u50CF\u304C\u30AB\u30D0\u30FC\u3068\u3057\u3066\u4F7F\u7528\u3055\u308C\u307E\u3059",
      "settings.behavior.use_first_image_as_cover.title": "\u6700\u521D\u306E\u753B\u50CF\u3092\u6295\u7A3F\u306E\u30AB\u30D0\u30FC\u3068\u3057\u3066\u4F7F\u7528\u3059\u308B",
      "settings.channel": "\u30C1\u30E3\u30F3\u30CD\u30EB",
      "settings.channel.create": "\u30C1\u30E3\u30F3\u30CD\u30EB\u3092\u4F5C\u6210\u3057\u307E\u3059\u3002",
      "settings.channel.desc": "\u4F7F\u7528\u3057\u305F\u3044\u30C1\u30E3\u30F3\u30CD\u30EB\u3092\u9078\u629E\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
      "settings.channel.empty": "\u30C1\u30E3\u30F3\u30CD\u30EB\u306A\u3057",
      "settings.channel.title": "\u30C1\u30E3\u30F3\u30CD\u30EB",
      "settings.editor": "\u7DE8\u96C6",
      "settings.editor.strict_line_breaks.desc": "Markdown \u4ED5\u69D8\u306F\u5358\u4E00\u884C\u306E\u6539\u884C\u3092\u7121\u8996\u3057\u307E\u3059\u3002\u3053\u308C\u3092\u4FDD\u6301\u3057\u305F\u3044\u5834\u5408\u306F\u3001\u3053\u306E\u30AA\u30D7\u30B7\u30E7\u30F3\u3092\u6709\u52B9\u306B\u3057\u3066\u304F\u3060\u3055\u3044\u3002",
      "settings.editor.strict_line_breaks.title": "\u53B3\u683C\u306A\u6539\u884C"
    };
  }
});

// src/i18n/lang/zh.json
var zh_default;
var init_zh = __esm({
  "src/i18n/lang/zh.json"() {
    zh_default = {
      "actions.ai_gen_metadata": "AI \u751F\u6210\u5143\u6570\u636E",
      "actions.insert_metadata": "\u63D2\u5165\u5143\u6570\u636E\u6A21\u677F",
      "actions.preview": "\u9884\u89C8",
      "actions.publish": "\u53D1\u5E03",
      "actions.save": "\u4FDD\u5B58",
      "actions.send": "\u63A8\u9001",
      "actions.set_channel": "\u8BBE\u7F6E\u9ED8\u8BA4\u9891\u9053",
      "actions.set_channel.select_channel": "\u9009\u62E9\u4E00\u4E2A\u9891\u9053",
      "actions.unpublish": "\u53D6\u6D88\u53D1\u5E03",
      "common.cancel": "\u53D6\u6D88",
      "common.close": "\u5173\u95ED",
      "common.copied": "\u590D\u5236",
      "common.generate": "\u751F\u6210",
      "common.login": "\u767B\u5F55",
      "common.logout": "\u767B\u51FA",
      "common.ok": "\u597D",
      "error_modal.copy": "\u590D\u5236\u6D88\u606F",
      "error_modal.error_message": "\u9519\u8BEF\u6D88\u606F",
      "error_modal.title": "\u54CE\u5440\uFF0C\u51FA\u4E86\u70B9\u95EE\u9898",
      "loading_modal.text.almost_there": "\u5FEB\u4E86",
      "loading_modal.text.just_a_moment": "\u7247\u523B",
      "loading_modal.text.loading": "\u52A0\u8F7D",
      "loading_modal.text.still_loading": "\u4ECD\u5728\u52A0\u8F7D",
      "loading_modal.text.working_on_it": "\u5728\u5E72\u6D3B",
      "message_modal.failed_to_verify_meta.title": "\u672A\u80FD\u9A8C\u8BC1\u5143\u6570\u636E",
      "message_modal.metadata_exists.desc": "\u8BF7\u624B\u52A8\u7F16\u8F91\u6216\u4F7F\u7528\u4EBA\u5DE5\u667A\u80FD\u751F\u6210\u3002",
      "message_modal.metadata_exists.title": "\u5143\u6570\u636E\u5DF2\u7ECF\u5B58\u5728",
      "message_modal.no_channels_found.desc": "\u8BF7\u9996\u5148\u521B\u5EFA\u4E00\u4E2A\u9891\u9053\u3002",
      "message_modal.no_channels_found.title": "\u6CA1\u6709\u9891\u9053",
      "message_modal.send_post.desc": "\u8FD9\u7BC7\u6587\u7AE0\u5DF2\u88AB\u6DFB\u52A0\u5230\u53D1\u9001\u961F\u5217\u4E2D\u3002\u53EF\u80FD\u9700\u8981\u51E0\u5206\u949F\u624D\u80FD\u53D1\u9001\u51FA\u53BB\u3002",
      "message_modal.send_post.title": "\u901A\u8FC7Quaily\u53D1\u9001",
      "message_modal.title": "Quaily \u7684\u6D88\u606F",
      "notices.post_saved": "\u2705 \u6587\u7AE0\u5DF2\u4FDD\u5B58\uFF01",
      "notices.set_channel_success": "\u2705 {title} \u662F\u9ED8\u8BA4\u9891\u9053\u3002",
      "notices.unpublish_success": "\u{1F4D5} \u672C\u5E16\u5DF2\u88AB\u53D6\u6D88\u53D1\u5E03\u3002\u4E0D\u518D\u5BF9\u8BFB\u8005\u53EF\u89C1\u3002",
      "preview_modal.desktop.desc": "\u70B9\u51FB\u5728\u6D4F\u89C8\u5668\u4E2D\u9884\u89C8",
      "preview_modal.desktop.title": "\u{1F4BB} \u684C\u9762\u9884\u89C8",
      "preview_modal.hint": "\u9884\u89C8\u5C06\u572810\u5206\u949F\u540E\u8FC7\u671F\u3002\u8BF7\u52FF\u4E0E\u4ED6\u4EBA\u5206\u4EAB\u94FE\u63A5\u3002",
      "preview_modal.mobile.desc": "\u626B\u63CF\u4E8C\u7EF4\u7801\u5728\u79FB\u52A8\u8BBE\u5907\u4E0A\u9884\u89C8",
      "preview_modal.mobile.title": "\u{1F4F1} \u79FB\u52A8\u7AEF\u9884\u89C8",
      "preview_modal.preview": "\u9884\u89C8",
      "preview_modal.title": "\u9884\u89C8\u6587\u7AE0",
      "publish_result_modal.copy_link": "\u590D\u5236\u94FE\u63A5",
      "publish_result_modal.title": "\u{1F389} \u6210\u529F\u53D1\u5E03\uFF01",
      "publish_result_modal.visit_post": "\u67E5\u770B\u6587\u7AE0",
      "settings.account.logged.desc": "\u5DF2\u767B\u5F55\u4E3A {email}",
      "settings.account.logged.title": "\u4F60\u597D\uFF0C{name}",
      "settings.account.need_to_login.desc": "\u8BF7\u767B\u5F55\u4EE5\u4F7F\u7528\u63D2\u4EF6",
      "settings.account.need_to_login.title": "\u767B\u5F55\u5230 Quaily",
      "settings.behavior": "\u884C\u4E3A",
      "settings.behavior.use_english_cmds.desc": "\u7EE7\u7EED\u5728 Obsidian \u547D\u4EE4\u9762\u677F\u4E2D\u4F7F\u7528\u82F1\u6587\u547D\u4EE4\uFF08\u9700\u8981\u91CD\u542F\u63D2\u4EF6\uFF09",
      "settings.behavior.use_english_cmds.title": "\u4F7F\u7528\u82F1\u6587\u547D\u4EE4",
      "settings.behavior.use_first_image_as_cover.desc": "\u5982\u679C\u5C01\u9762\u4E3A\u7A7A\uFF0C\u5C06\u4F7F\u7528\u6587\u7AE0\u4E2D\u7684\u7B2C\u4E00\u5F20\u56FE\u7247",
      "settings.behavior.use_first_image_as_cover.title": "\u4F7F\u7528\u7B2C\u4E00\u5F20\u56FE\u7247\u4F5C\u4E3A\u5C01\u9762",
      "settings.channel": "\u9891\u9053",
      "settings.channel.create": "\u521B\u5EFA\u9891\u9053",
      "settings.channel.desc": "\u9009\u62E9\u60F3\u8981\u4F7F\u7528\u7684\u9891\u9053\u3002",
      "settings.channel.empty": "\u6CA1\u6709\u9891\u9053",
      "settings.channel.title": "\u9891\u9053",
      "settings.editor": "\u7F16\u8F91\u5668",
      "settings.editor.strict_line_breaks.desc": "Markdown \u89C4\u8303\u5FFD\u7565\u5355\u884C\u6362\u884C\u3002\u5982\u679C\u60F3\u4FDD\u7559\u5B83\u4EEC\uFF0C\u8BF7\u542F\u7528\u6B64\u9009\u9879\u3002",
      "settings.editor.strict_line_breaks.title": "\u4E25\u683C\u7684\u6362\u884C"
    };
  }
});

// src/i18n/lang/zh-tw.json
var zh_tw_default;
var init_zh_tw = __esm({
  "src/i18n/lang/zh-tw.json"() {
    zh_tw_default = {
      "actions.ai_gen_metadata": "AI \u751F\u6210\u5143\u6578\u64DA",
      "actions.insert_metadata": "\u63D2\u5165\u5143\u6578\u64DA\u6A21\u677F",
      "actions.preview": "\u9810\u89BD",
      "actions.publish": "\u767C\u4F48",
      "actions.save": "\u4FDD\u5B58",
      "actions.send": "\u63A8\u9001",
      "actions.set_channel": "\u8A2D\u7F6E\u9ED8\u8A8D\u983B\u9053",
      "actions.set_channel.select_channel": "\u9078\u64C7\u4E00\u500B\u983B\u9053",
      "actions.unpublish": "\u53D6\u6D88\u767C\u4F48",
      "common.cancel": "\u53D6\u6D88",
      "common.close": "\u95DC\u9589",
      "common.copied": "\u8907\u88FD",
      "common.generate": "\u751F\u6210",
      "common.login": "\u767B\u5165",
      "common.logout": "\u767B\u51FA",
      "common.ok": "\u597D",
      "error_modal.copy": "\u8907\u88FD\u8A0A\u606F",
      "error_modal.error_message": "\u932F\u8AA4\u8A0A\u606F",
      "error_modal.title": "\u54CE\u5440\uFF0C\u51FA\u4E86\u9EDE\u554F\u984C\u3002",
      "loading_modal.text.almost_there": "\u5FEB\u5230\u4E86",
      "loading_modal.text.just_a_moment": "\u7B49\u4E00\u4E0B",
      "loading_modal.text.loading": "\u8F09\u5165\u4E2D",
      "loading_modal.text.still_loading": "\u8F09\u5165\u4E2D",
      "loading_modal.text.working_on_it": "\u6B63\u5728\u52AA\u529B",
      "message_modal.failed_to_verify_meta.title": "\u7121\u6CD5\u9A57\u8B49\u5143\u6578\u64DA",
      "message_modal.metadata_exists.desc": "\u8ACB\u624B\u52D5\u7DE8\u8F2F\u6216\u4F7F\u7528\u4EBA\u5DE5\u667A\u6167\u751F\u6210\u3002",
      "message_modal.metadata_exists.title": "\u5143\u6578\u64DA\u5DF2\u5B58\u5728",
      "message_modal.no_channels_found.desc": "\u8ACB\u5148\u5EFA\u7ACB\u4E00\u500B\u983B\u9053\u3002",
      "message_modal.no_channels_found.title": "\u7121\u983B\u9053",
      "message_modal.send_post.desc": "\u9019\u7BC7\u6587\u7AE0\u5DF2\u7D93\u88AB\u52A0\u5165\u5BC4\u9001\u4F47\u5217\u4E2D\u3002\u53EF\u80FD\u9700\u8981\u5E7E\u5206\u9418\u624D\u80FD\u5BC4\u51FA\u3002",
      "message_modal.send_post.title": "\u900F\u904EQuaily\u767C\u9001",
      "message_modal.title": "Quaily \u7684\u4E00\u5247\u8A0A\u606F",
      "notices.post_saved": "\u2705 \u6587\u7AE0\u5DF2\u5132\u5B58\uFF01",
      "notices.set_channel_success": "\u2705 {title} \u662F\u9810\u8A2D\u983B\u9053\u3002",
      "notices.unpublish_success": "\u{1F4D5} \u9019\u7BC7\u6587\u7AE0\u5DF2\u88AB\u53D6\u6D88\u767C\u4F48\u3002\u8B80\u8005\u5C07\u7121\u6CD5\u770B\u5230\u3002",
      "preview_modal.desktop.desc": "\u9EDE\u64CA\u5728\u700F\u89BD\u5668\u4E2D\u9810\u89BD",
      "preview_modal.desktop.title": "\u{1F4BB} \u5728\u684C\u9762\u4E0A\u9810\u89BD",
      "preview_modal.hint": "\u9810\u89BD\u5C07\u572810\u5206\u9418\u5F8C\u904E\u671F\u3002\u8ACB\u52FF\u8207\u4ED6\u4EBA\u5206\u4EAB\u93C8\u63A5\u3002",
      "preview_modal.mobile.desc": "\u6383\u63CFQR\u78BC\u5728\u624B\u6A5F\u4E0A\u9810\u89BD",
      "preview_modal.mobile.title": "\u{1F4F1} \u624B\u6A5F\u9810\u89BD",
      "preview_modal.preview": "\u9810\u89BD",
      "preview_modal.title": "\u9810\u89BD\u6587\u7AE0",
      "publish_result_modal.copy_link": "\u8907\u88FD\u93C8\u63A5",
      "publish_result_modal.title": "\u{1F389} \u6210\u529F\u767C\u4F48\uFF01",
      "publish_result_modal.visit_post": "\u67E5\u770B\u6587\u7AE0",
      "settings.account.logged.desc": "\u5DF2\u767B\u5165\u70BA {email}",
      "settings.account.logged.title": "\u4F60\u597D\uFF0C{name}",
      "settings.account.need_to_login.desc": "\u8ACB\u767B\u5165\u4EE5\u4F7F\u7528\u63D2\u4EF6",
      "settings.account.need_to_login.title": "\u767B\u5165 Quaily",
      "settings.behavior": "\u884C\u70BA",
      "settings.behavior.use_english_cmds.desc": "\u5728 Obsidian \u547D\u4EE4\u9762\u677F\u4E2D\u7E7C\u7E8C\u4F7F\u7528\u82F1\u6587\u547D\u4EE4\uFF08\u9700\u8981\u91CD\u555F\u5916\u639B\uFF09",
      "settings.behavior.use_english_cmds.title": "\u4F7F\u7528\u82F1\u6587\u547D\u4EE4",
      "settings.behavior.use_first_image_as_cover.desc": "\u5982\u679C\u5C01\u9762\u70BA\u7A7A\uFF0C\u5C07\u4F7F\u7528\u6587\u7AE0\u4E2D\u7684\u7B2C\u4E00\u5F35\u5716\u7247",
      "settings.behavior.use_first_image_as_cover.title": "\u4F7F\u7528\u7B2C\u4E00\u5F35\u5716\u7247\u4F5C\u70BA\u6587\u7AE0\u5C01\u9762",
      "settings.channel": "\u983B\u9053",
      "settings.channel.create": "\u5275\u5EFA\u983B\u9053",
      "settings.channel.desc": "\u9078\u64C7\u8981\u4F7F\u7528\u7684\u983B\u9053\u3002",
      "settings.channel.empty": "\u6C92\u6709\u983B\u9053",
      "settings.channel.title": "\u983B\u9053",
      "settings.editor": "\u7DE8\u8F2F\u5668",
      "settings.editor.strict_line_breaks.desc": "Markdown \u5FFD\u7565\u55AE\u884C\u63DB\u884C\u3002\u5982\u679C\u60F3\u4FDD\u7559\u5B83\u5011\uFF0C\u8ACB\u555F\u7528\u6B64\u9078\u9805\u3002",
      "settings.editor.strict_line_breaks.title": "\u56B4\u683C\u7684\u63DB\u884C"
    };
  }
});

// src/i18n/index.ts
function detectLang() {
  let lang = window.localStorage.getItem("language");
  if (lang && supportedLangs.includes(lang)) {
    return lang;
  }
  lang = navigator.language.toLowerCase();
  if (lang.length > 5) {
    lang = lang.substring(0, 5);
  }
  if (lang && supportedLangs.includes(lang)) {
    return lang;
  } else {
    return "en";
  }
}
function _t(lang, name, data) {
  const locale = messages2[lang];
  let msg = "";
  if (locale) {
    msg = locale[name];
    if (typeof msg === "undefined") {
      msg = messages2.en[name];
      if (typeof msg === "undefined") {
        msg = name;
      }
    }
  }
  if (data) {
    for (const key in data) {
      msg = msg.replace(`{${key}}`, data[key]);
    }
  }
  return msg;
}
function t(name, data) {
  const lang = detectLang();
  return _t(lang, name, data);
}
function english(name, data) {
  return _t("en", name, data);
}
var supportedLangs, messages2;
var init_i18n = __esm({
  "src/i18n/index.ts"() {
    init_en();
    init_ja();
    init_zh();
    init_zh_tw();
    supportedLangs = [
      "en",
      "ja",
      "zh",
      "zh-tw"
    ];
    messages2 = {
      en: en_default,
      ja: ja_default,
      zh: zh_default,
      "zh-tw": zh_tw_default
    };
  }
});

// src/modals/ErrorModal.ts
var import_obsidian, ErrorModal;
var init_ErrorModal = __esm({
  "src/modals/ErrorModal.ts"() {
    import_obsidian = require("obsidian");
    init_utils();
    init_i18n();
    ErrorModal = class extends import_obsidian.Modal {
      constructor(app, error) {
        super(app);
        this.message = "";
        this.message = error.message;
      }
      onOpen() {
        const { contentEl } = this;
        constructModalTitle(contentEl, t("error_modal.title"));
        const p = document.createElement("p");
        Object.assign(p.style, {
          color: "var(--text-muted)",
          textAlign: "center"
        });
        p.appendText(t("error_modal.error_message"));
        const pre = document.createElement("pre");
        pre.className = "error-message";
        Object.assign(pre.style, {
          fontSize: "0.8rem"
        });
        const code = document.createElement("code");
        code.appendText(this.message);
        pre.appendChild(code);
        p.appendChild(pre);
        contentEl.appendChild(p);
        const buttonContainer = contentEl.createDiv();
        Object.assign(buttonContainer.style, {
          display: "flex",
          gap: "0.5rem",
          justifyContent: "center",
          marginBottom: "0.5rem"
        });
        const visitButton = buttonContainer.createEl("button", {
          cls: "mod-cta",
          text: t("common.close")
        });
        Object.assign(visitButton.style, {
          minWidth: "100px"
        });
        visitButton.onclick = () => {
          this.close();
        };
        const copyButton = buttonContainer.createEl("button", {
          text: t("error_modal.copy")
        });
        Object.assign(copyButton.style, {
          minWidth: "100px"
        });
        copyButton.onclick = async () => {
          await navigator.clipboard.writeText(this.message);
          copyButton.setText(t("common.copied"));
          setTimeout(() => {
            copyButton.setText(t("error_modal.copy"));
          }, 2e3);
        };
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// src/modals/MessageModal.ts
var import_obsidian2, MessageModal;
var init_MessageModal = __esm({
  "src/modals/MessageModal.ts"() {
    import_obsidian2 = require("obsidian");
    init_i18n();
    MessageModal = class extends import_obsidian2.Modal {
      constructor(app, { title, message, icon, iconColor, actions }) {
        super(app);
        this.message = "";
        this.title = "";
        this.icon = "\u{1F916}";
        this.iconColor = "accent";
        this.iconColors = {
          "green": {
            "dimm-1": "rgba(16, 185, 129, .05)",
            "dimm-2": "rgba(16, 185, 129, .2)"
          },
          "red": {
            "dimm-1": "rgba(244, 63, 94, .05)",
            "dimm-2": "rgba(244, 63, 94, .2)"
          },
          "orange": {
            "dimm-1": "rgba(234, 179, 8, .05)",
            "dimm-2": "rgba(234, 179, 8, .2)"
          },
          "blue": {
            "dimm-1": "rgba(13, 117, 252, .05)",
            "dimm-2": "rgba(13, 117, 252, .2)"
          }
        };
        this.actions = [];
        this.message = message;
        this.title = title || t("message_modal.title");
        this.icon = icon || "\u{1F916}";
        this.iconColor = iconColor || "accent";
        this.actions = actions || [{
          text: t("common.ok"),
          primary: true,
          click: () => {
            this.close();
          }
        }];
      }
      onOpen() {
        const { contentEl } = this;
        this.setTitle("");
        const text = this.message.replace(/\n/g, "<br/>");
        const container = contentEl.createDiv();
        Object.assign(container.style, {
          display: "flex",
          margin: "0",
          flexDirection: "column",
          alignItems: "center"
        });
        const iconWrapper = container.createDiv();
        Object.assign(iconWrapper.style, {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          margin: "0 0 1.5rem 0"
        });
        const iconInner = iconWrapper.createDiv();
        Object.assign(iconInner.style, {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          margin: "0",
          borderRadius: "50em",
          padding: "0.5rem"
        });
        if (this.iconColors[this.iconColor]) {
          Object.assign(iconInner.style, {
            backgroundColor: this.iconColors[this.iconColor]["dimm-2"],
            boxShadow: `0 0 0 8px ${this.iconColors[this.iconColor]["dimm-1"]}`
          });
        } else {
          Object.assign(iconInner.style, {
            backgroundColor: `hsl(calc(var(--accent-h) - 1), calc(var(--accent-s) * 1.01), calc(var(--accent-l) * 1.4))`,
            boxShadow: `0 0 0 8px hsl(calc(var(--accent-h) - 1), calc(var(--accent-s) * 1.01), calc(var(--accent-l) * 1.47))`
          });
        }
        const icon = iconInner.createDiv();
        Object.assign(icon.style, {
          height: "22px",
          width: "22px",
          borderRadius: "50em",
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        });
        icon.innerText = this.icon;
        const content = container.createDiv();
        Object.assign(content.style, {
          flex: "1",
          margin: "0 1rem",
          textAlign: "center"
        });
        const t2 = content.createEl("h2", {
          text: this.title
        });
        Object.assign(t2.style, {
          fontSize: "1rem",
          fontWeight: "bold",
          margin: "0 0 0.5rem 0"
        });
        const p = content.createDiv();
        Object.assign(p.style, {
          lineHeight: "1.5",
          color: "var(--text-muted)",
          margin: "0 0 1rem 0"
        });
        p.innerHTML = text;
        const buttonContainer = container.createDiv();
        Object.assign(buttonContainer.style, {
          display: "flex",
          justifyContent: "center",
          margin: "0 0 0.5rem 0",
          gap: "0.5rem"
        });
        for (const action of this.actions) {
          const button = buttonContainer.createEl("button", {
            text: action.text
          });
          Object.assign(button.style, {
            minWidth: "100px"
          });
          if (action.primary) {
            button.classList.add("mod-cta");
          }
          if (action.danger) {
            button.classList.add("mod-warning");
          }
          if (action.close) {
            button.addEventListener("click", () => {
              this.close();
            });
          } else {
            if (action.click) {
              button.addEventListener("click", () => {
                action.click(this);
              });
            }
          }
          button.focus();
        }
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// src/modals/PublishResultModal.ts
var import_obsidian3, PublishResultModal;
var init_PublishResultModal = __esm({
  "src/modals/PublishResultModal.ts"() {
    import_obsidian3 = require("obsidian");
    init_utils();
    init_i18n();
    PublishResultModal = class extends import_obsidian3.Modal {
      constructor(app, client, { scene, url, title, summary, coverImageUrl }) {
        super(app);
        this.url = url;
        this.dialogTitle = t("publish_result_modal.title");
        this.title = title || "";
        this.summary = summary || "";
        this.coverImageUrl = coverImageUrl || null;
        this.client = client;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        this.setTitle("");
        const container = contentEl.createDiv();
        Object.assign(container.style, {
          maxWidth: "600px"
        });
        constructModalTitle(container, this.dialogTitle);
        const postPreview = container.createDiv();
        Object.assign(postPreview.style, {
          margin: "0 0 1rem 0",
          display: "flex",
          background: "var(--background-primary)",
          padding: "var(--size-4-3)",
          borderRadius: "var(--radius-s)",
          border: "1px solid var(--background-modifier-border)"
        });
        if (this.coverImageUrl) {
          const imageContainer = postPreview.createDiv();
          Object.assign(imageContainer.style, {
            margin: "0 1rem 0 0",
            width: "128px",
            height: "128px",
            flexBasis: "128px",
            minWidth: "128px",
            borderRadius: "2px",
            boxShadow: "0 3px 10px rgba(0, 0, 0, 0.05)"
          });
          const img = imageContainer.createEl("img", {
            attr: {
              src: this.coverImageUrl,
              alt: "Post cover image"
            }
          });
          Object.assign(img.style, {
            width: "100%",
            height: "100%",
            objectFit: "cover",
            borderRadius: "2px"
          });
        }
        const postContent = postPreview.createDiv();
        if (this.title) {
          const postTitle = postContent.createEl("h3", {
            text: this.title
          });
          Object.assign(postTitle.style, {
            margin: "0 0 0.5rem 0",
            fontSize: "1.5em",
            fontWeight: "600"
          });
        }
        if (this.summary) {
          const summaryEl = postContent.createEl("p", {
            text: this.summary
          });
          Object.assign(summaryEl.style, {
            margin: "0",
            lineHeight: "1.5",
            color: "var(--text-muted)",
            WebkitLineClamp: "2",
            WebkitBoxOrient: "vertical",
            display: "-webkit-box",
            overflow: "hidden"
          });
        }
        const urlContainer = container.createDiv();
        Object.assign(urlContainer.style, {
          background: "var(--background-secondary)",
          padding: "0.75rem",
          borderRadius: "6px",
          margin: "1rem 0",
          wordBreak: "break-all"
        });
        const urlLink = urlContainer.createEl("a", {
          href: this.url,
          text: this.url
        });
        Object.assign(urlLink.style, {
          color: "var(--text-accent)",
          textDecoration: "none"
        });
        urlLink.setAttribute("target", "_blank");
        const buttonContainer = container.createDiv();
        Object.assign(buttonContainer.style, {
          display: "flex",
          gap: "0.5rem",
          justifyContent: "center",
          marginBottom: "0.5rem"
        });
        const copyButton = buttonContainer.createEl("button", {
          text: t("publish_result_modal.copy_link")
        });
        Object.assign(copyButton.style, {
          minWidth: "100px"
        });
        copyButton.onclick = async () => {
          await navigator.clipboard.writeText(this.url);
          copyButton.setText(t("common.copied"));
          setTimeout(() => {
            copyButton.setText(t("publish_result_modal.copy_link"));
          }, 2e3);
        };
        const visitButton = buttonContainer.createEl("button", {
          cls: "mod-cta",
          text: t("publish_result_modal.visit_post")
        });
        Object.assign(visitButton.style, {
          minWidth: "100px"
        });
        visitButton.onclick = () => {
          window.open(this.url, "_blank");
          this.close();
        };
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// src/modals/LoadingModal.ts
var import_obsidian4, LoadingModal;
var init_LoadingModal = __esm({
  "src/modals/LoadingModal.ts"() {
    import_obsidian4 = require("obsidian");
    init_i18n();
    LoadingModal = class extends import_obsidian4.Modal {
      constructor(app) {
        super(app);
        this.loadingInterval = null;
        this.frames = [
          "\u{1F610}",
          "\u{1F610}",
          "\u{1F610}",
          "\u{1F610}",
          "\u{1F610}",
          "\u{1F610}",
          "\u{1F610}",
          "\u{1F610}",
          "\u{1F610}",
          "\u{1F610}",
          "\u{1F610}",
          "\u{1F611}",
          "\u{1F610}",
          "\u{1F610}",
          "\u{1F610}",
          "\u{1F610}",
          "\u{1F611}"
        ];
        this.currentFrame = 0;
        this.loadingTextElement = null;
        this.asciiArtElement = null;
        this.loadingTexts = [
          t("loading_modal.text.loading"),
          t("loading_modal.text.still_loading"),
          t("loading_modal.text.almost_there"),
          t("loading_modal.text.just_a_moment"),
          t("loading_modal.text.working_on_it")
        ];
        this.textIndex = 0;
        this.textOpacity = 1;
        this.fadeDirection = "out";
      }
      onOpen() {
        this.setTitle("");
        const { contentEl } = this;
        this.asciiArtElement = document.createElement("pre");
        this.asciiArtElement.className = "loading-ascii-art";
        Object.assign(this.asciiArtElement.style, {
          fontSize: "40px",
          lineHeight: "1.2",
          margin: "1rem 0",
          textAlign: "center"
        });
        contentEl.appendChild(this.asciiArtElement);
        this.loadingTextElement = document.createElement("p");
        this.loadingTextElement.className = "text-center loading-text";
        Object.assign(this.loadingTextElement.style, {
          marginTop: "10px",
          transition: "opacity 0.3s ease",
          fontSize: "0.7rem"
        });
        this.loadingTextElement.setText(this.loadingTexts[this.textIndex]);
        contentEl.appendChild(this.loadingTextElement);
        this.updateFrame();
        this.loadingInterval = window.setInterval(() => {
          this.updateFrame();
        }, 100);
      }
      updateFrame() {
        if (!this.asciiArtElement || !this.loadingTextElement)
          return;
        this.currentFrame = (this.currentFrame + 1) % this.frames.length;
        const cuteArt = [
          " " + this.frames[this.currentFrame] + " "
        ].join("\n");
        this.asciiArtElement.setText(cuteArt);
        if (this.fadeDirection === "out") {
          this.textOpacity -= 0.1;
          if (this.textOpacity <= 0) {
            this.textOpacity = 0;
            this.fadeDirection = "in";
            this.textIndex = (this.textIndex + 1) % this.loadingTexts.length;
            this.loadingTextElement.setText(this.loadingTexts[this.textIndex]);
          }
        } else {
          this.textOpacity += 0.1;
          if (this.textOpacity >= 1) {
            this.textOpacity = 1;
            this.fadeDirection = "out";
          }
        }
        this.loadingTextElement.style.opacity = this.textOpacity.toString();
      }
      onClose() {
        const { contentEl } = this;
        if (this.loadingInterval) {
          clearInterval(this.loadingInterval);
          this.loadingInterval = null;
        }
        contentEl.empty();
      }
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/can-promise.js"(exports, module2) {
    module2.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/utils.js
var require_utils = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/utils.js"(exports) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version) {
      if (!version)
        throw new Error('"version" cannot be null or undefined');
      if (version < 1 || version > 40)
        throw new Error('"version" should be in range from 1 to 40');
      return version * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version) {
      return CODEWORDS_COUNT[version];
    };
    exports.getBCHDigit = function(data) {
      let digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f) {
      if (typeof f !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-buffer.js"(exports, module2) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index) {
        const bufIndex = Math.floor(index / 8);
        return (this.buffer[bufIndex] >>> 7 - index % 8 & 1) === 1;
      },
      put: function(num, length) {
        for (let i = 0; i < length; i++) {
          this.putBit((num >>> length - i - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module2.exports = BitBuffer;
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/bit-matrix.js"(exports, module2) {
    function BitMatrix(size) {
      if (!size || size < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size;
      this.data = new Uint8Array(size * size);
      this.reservedBit = new Uint8Array(size * size);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      const index = row * this.size + col;
      this.data[index] = value;
      if (reserved)
        this.reservedBit[index] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module2.exports = BitMatrix;
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version) {
      if (version === 1)
        return [];
      const posCount = Math.floor(version / 7) + 2;
      const size = getSymbolSize(version);
      const intervals = size === 145 ? 26 : Math.ceil((size - 13) / (2 * posCount - 2)) * 2;
      const positions = [size - 7];
      for (let i = 1; i < posCount - 1; i++) {
        positions[i] = positions[i - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version) {
      const coords = [];
      const pos = exports.getRowColCoords(version);
      const posLength = pos.length;
      for (let i = 0; i < posLength; i++) {
        for (let j = 0; j < posLength; j++) {
          if (i === 0 && j === 0 || // top-left
          i === 0 && j === posLength - 1 || // bottom-left
          i === posLength - 1 && j === 0) {
            continue;
          }
          coords.push([pos[i], pos[j]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    var getSymbolSize = require_utils().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version) {
      const size = getSymbolSize(version);
      return [
        // top-left
        [0, 0],
        // top-right
        [size - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      const size = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size; col++) {
          let module3 = data.get(row, col);
          if (module3 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5)
              points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module3;
            sameCountCol = 1;
          }
          module3 = data.get(col, row);
          if (module3 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5)
              points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module3;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5)
          points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5)
          points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      const size = data.size;
      let points = 0;
      for (let row = 0; row < size - 1; row++) {
        for (let col = 0; col < size - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0)
            points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      const size = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93))
            points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93))
            points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;
      for (let i = 0; i < modulesCount; i++)
        darkCount += data.data[i];
      const k = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i, j) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i + j) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i + j) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i * j % 2 + i * j % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i * j % 2 + i * j % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i * j % 3 + (i + j) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      const size = data.size;
      for (let col = 0; col < size; col++) {
        for (let row = 0; row < size; row++) {
          if (data.isReserved(row, col))
            continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p = 0; p < numPatterns; p++) {
        setupFormatFunc(p);
        exports.applyMask(p, data);
        const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/galois-field.js"(exports) {
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (function initTables() {
      let x = 1;
      for (let i = 0; i < 255; i++) {
        EXP_TABLE[i] = x;
        LOG_TABLE[x] = i;
        x <<= 1;
        if (x & 256) {
          x ^= 285;
        }
      }
      for (let i = 255; i < 512; i++) {
        EXP_TABLE[i] = EXP_TABLE[i - 255];
      }
    })();
    exports.log = function log(n) {
      if (n < 1)
        throw new Error("log(" + n + ")");
      return LOG_TABLE[n];
    };
    exports.exp = function exp(n) {
      return EXP_TABLE[n];
    };
    exports.mul = function mul(x, y) {
      if (x === 0 || y === 0)
        return 0;
      return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]];
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/polynomial.js"(exports) {
    var GF = require_galois_field();
    exports.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i = 0; i < p1.length; i++) {
        for (let j = 0; j < p2.length; j++) {
          coeff[i + j] ^= GF.mul(p1[i], p2[j]);
        }
      }
      return coeff;
    };
    exports.mod = function mod(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i = 0; i < divisor.length; i++) {
          result[i] ^= GF.mul(divisor[i], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0)
          offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i = 0; i < degree; i++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]));
      }
      return poly;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module2) {
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree)
        this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    };
    module2.exports = ReedSolomonEncoder;
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version-check.js"(exports) {
    exports.isValid = function isValid(version) {
      return !isNaN(version) && version >= 1 && version <= 40;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/regex.js"(exports) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/mode.js"(exports) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode, version) {
      if (!mode.ccBits)
        throw new Error("Invalid mode: " + mode);
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid version: " + version);
      }
      if (version >= 1 && version < 10)
        return mode.ccBits[0];
      else if (version < 27)
        return mode.ccBits[1];
      return mode.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr))
        return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr))
        return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr))
        return exports.KANJI;
      else
        return exports.BYTE;
    };
    exports.toString = function toString(mode) {
      if (mode && mode.id)
        return mode.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode) {
      return mode && mode.bit && mode.ccBits;
    };
    function fromString(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString(value);
      } catch (e) {
        return defaultValue;
      }
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/version.js"(exports) {
    var Utils = require_utils();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode, length, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode, version) {
      return Mode.getCharCountIndicator(mode, version) + 4;
    }
    function getTotalBitsFromDataArray(segments, version) {
      let totalBits = 0;
      segments.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length = getTotalBitsFromDataArray(segments, currentVersion);
        if (length <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version, errorCorrectionLevel, mode) {
      if (!VersionCheck.isValid(version)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode === "undefined")
        mode = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode === Mode.MIXED)
        return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode, version);
      switch (mode) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version) {
      if (!VersionCheck.isValid(version) || version < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d = version << 12;
      while (Utils.getBCHDigit(d) - G18_BCH >= 0) {
        d ^= G18 << Utils.getBCHDigit(d) - G18_BCH;
      }
      return version << 12 | d;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/format-info.js"(exports) {
    var Utils = require_utils();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      const data = errorCorrectionLevel.bit << 3 | mask;
      let d = data << 10;
      while (Utils.getBCHDigit(d) - G15_BCH >= 0) {
        d ^= G15 << Utils.getBCHDigit(d) - G15_BCH;
      }
      return (data << 10 | d) ^ G15_MASK;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/numeric-data.js"(exports, module2) {
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length) {
      return 10 * Math.floor(length / 3) + (length % 3 ? length % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      let i, group, value;
      for (i = 0; i + 3 <= this.data.length; i += 3) {
        group = this.data.substr(i, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      const remainingNum = this.data.length - i;
      if (remainingNum > 0) {
        group = this.data.substr(i);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module2.exports = NumericData;
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module2) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length) {
      return 11 * Math.floor(length / 2) + 6 * (length % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i;
      for (i = 0; i + 2 <= this.data.length; i += 2) {
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6);
      }
    };
    module2.exports = AlphanumericData;
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/byte-data.js"(exports, module2) {
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      if (typeof data === "string") {
        this.data = new TextEncoder().encode(data);
      } else {
        this.data = new Uint8Array(data);
      }
    }
    ByteData.getBitsLength = function getBitsLength(length) {
      return length * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (let i = 0, l = this.data.length; i < l; i++) {
        bitBuffer.put(this.data[i], 8);
      }
    };
    module2.exports = ByteData;
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/kanji-data.js"(exports, module2) {
    var Mode = require_mode();
    var Utils = require_utils();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length) {
      return length * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      let i;
      for (i = 0; i < this.data.length; i++) {
        let value = Utils.toSJIS(this.data[i]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module2.exports = KanjiData;
  }
});

// node_modules/.pnpm/dijkstrajs@1.0.3/node_modules/dijkstrajs/dijkstra.js
var require_dijkstra = __commonJS({
  "node_modules/.pnpm/dijkstrajs@1.0.3/node_modules/dijkstrajs/dijkstra.js"(exports, module2) {
    "use strict";
    var dijkstra = {
      single_source_shortest_paths: function(graph, s, d) {
        var predecessors = {};
        var costs = {};
        costs[s] = 0;
        var open = dijkstra.PriorityQueue.make();
        open.push(s, 0);
        var closest, u, v, cost_of_s_to_u, adjacent_nodes, cost_of_e, cost_of_s_to_u_plus_cost_of_e, cost_of_s_to_v, first_visit;
        while (!open.empty()) {
          closest = open.pop();
          u = closest.value;
          cost_of_s_to_u = closest.cost;
          adjacent_nodes = graph[u] || {};
          for (v in adjacent_nodes) {
            if (adjacent_nodes.hasOwnProperty(v)) {
              cost_of_e = adjacent_nodes[v];
              cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e;
              cost_of_s_to_v = costs[v];
              first_visit = typeof costs[v] === "undefined";
              if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
                costs[v] = cost_of_s_to_u_plus_cost_of_e;
                open.push(v, cost_of_s_to_u_plus_cost_of_e);
                predecessors[v] = u;
              }
            }
          }
        }
        if (typeof d !== "undefined" && typeof costs[d] === "undefined") {
          var msg = ["Could not find a path from ", s, " to ", d, "."].join("");
          throw new Error(msg);
        }
        return predecessors;
      },
      extract_shortest_path_from_predecessor_list: function(predecessors, d) {
        var nodes = [];
        var u = d;
        var predecessor;
        while (u) {
          nodes.push(u);
          predecessor = predecessors[u];
          u = predecessors[u];
        }
        nodes.reverse();
        return nodes;
      },
      find_path: function(graph, s, d) {
        var predecessors = dijkstra.single_source_shortest_paths(graph, s, d);
        return dijkstra.extract_shortest_path_from_predecessor_list(
          predecessors,
          d
        );
      },
      /**
       * A very naive priority queue implementation.
       */
      PriorityQueue: {
        make: function(opts) {
          var T = dijkstra.PriorityQueue, t2 = {}, key;
          opts = opts || {};
          for (key in T) {
            if (T.hasOwnProperty(key)) {
              t2[key] = T[key];
            }
          }
          t2.queue = [];
          t2.sorter = opts.sorter || T.default_sorter;
          return t2;
        },
        default_sorter: function(a, b) {
          return a.cost - b.cost;
        },
        /**
         * Add a new item to the queue and ensure the highest priority element
         * is at the front of the queue.
         */
        push: function(value, cost) {
          var item = { value, cost };
          this.queue.push(item);
          this.queue.sort(this.sorter);
        },
        /**
         * Return the highest priority element in the queue.
         */
        pop: function() {
          return this.queue.shift();
        },
        empty: function() {
          return this.queue.length === 0;
        }
      }
    };
    if (typeof module2 !== "undefined") {
      module2.exports = dijkstra;
    }
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/segments.js"(exports) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode, str) {
      const segments = [];
      let result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length, mode) {
      switch (mode) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length);
        case Mode.BYTE:
          return ByteData.getBitsLength(length);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i = 0; i < segs.length; i++) {
        const seg = segs[i];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i = 0; i < nodes.length; i++) {
        const nodeGroup = nodes[i];
        const currentNodeIds = [];
        for (let j = 0; j < nodeGroup.length; j++) {
          const node = nodeGroup[j];
          const key = "" + i + j;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n = 0; n < prevNodeIds.length; n++) {
            const prevNodeId = prevNodeIds[n];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId])
                table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n = 0; n < prevNodeIds.length; n++) {
        graph[prevNodeIds[n]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      let mode;
      const bestMode = Mode.getBestModeForData(data);
      mode = Mode.from(modesHint, bestMode);
      if (mode !== Mode.BYTE && mode.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode = Mode.BYTE;
      }
      switch (mode) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString(data, version) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version);
      const path = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i = 1; i < path.length - 1; i++) {
        optimizedSegs.push(graph.table[path[i]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/core/qrcode.js"(exports) {
    var Utils = require_utils();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix, version) {
      const size = matrix.size;
      const pos = FinderPattern.getPositions(version);
      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];
        for (let r = -1; r <= 7; r++) {
          if (row + r <= -1 || size <= row + r)
            continue;
          for (let c = -1; c <= 7; c++) {
            if (col + c <= -1 || size <= col + c)
              continue;
            if (r >= 0 && r <= 6 && (c === 0 || c === 6) || c >= 0 && c <= 6 && (r === 0 || r === 6) || r >= 2 && r <= 4 && c >= 2 && c <= 4) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      const size = matrix.size;
      for (let r = 8; r < size - 8; r++) {
        const value = r % 2 === 0;
        matrix.set(r, 6, value, true);
        matrix.set(6, r, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version) {
      const pos = AlignmentPattern.getPositions(version);
      for (let i = 0; i < pos.length; i++) {
        const row = pos[i][0];
        const col = pos[i][1];
        for (let r = -2; r <= 2; r++) {
          for (let c = -2; c <= 2; c++) {
            if (r === -2 || r === 2 || c === -2 || c === 2 || r === 0 && c === 0) {
              matrix.set(row + r, col + c, true, true);
            } else {
              matrix.set(row + r, col + c, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version) {
      const size = matrix.size;
      const bits = Version.getEncodedBits(version);
      let row, col, mod;
      for (let i = 0; i < 18; i++) {
        row = Math.floor(i / 3);
        col = i % 3 + size - 8 - 3;
        mod = (bits >> i & 1) === 1;
        matrix.set(row, col, mod, true);
        matrix.set(col, row, mod, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i, mod;
      for (i = 0; i < 15; i++) {
        mod = (bits >> i & 1) === 1;
        if (i < 6) {
          matrix.set(i, 8, mod, true);
        } else if (i < 8) {
          matrix.set(i + 1, 8, mod, true);
        } else {
          matrix.set(size - 15 + i, 8, mod, true);
        }
        if (i < 8) {
          matrix.set(8, size - i - 1, mod, true);
        } else if (i < 9) {
          matrix.set(8, 15 - i - 1 + 1, mod, true);
        } else {
          matrix.set(8, 15 - i - 1, mod, true);
        }
      }
      matrix.set(size - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      const size = matrix.size;
      let inc = -1;
      let row = size - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size - 1; col > 0; col -= 2) {
        if (col === 6)
          col--;
        while (true) {
          for (let c = 0; c < 2; c++) {
            if (!matrix.isReserved(row, col - c)) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version, errorCorrectionLevel, segments) {
      const buffer = new BitBuffer();
      segments.forEach(function(data) {
        buffer.put(data.mode.bit, 4);
        buffer.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version));
        data.write(buffer);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer.put(0, 4);
      }
      while (buffer.getLengthInBits() % 8 !== 0) {
        buffer.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8;
      for (let i = 0; i < remainingByte; i++) {
        buffer.put(i % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer, version, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer = new Uint8Array(bitBuffer.buffer);
      for (let b = 0; b < ecTotalBlocks; b++) {
        const dataSize = b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b] = buffer.slice(offset, offset + dataSize);
        ecData[b] = rs.encode(dcData[b]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data = new Uint8Array(totalCodewords);
      let index = 0;
      let i, r;
      for (i = 0; i < maxDataSize; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          if (i < dcData[r].length) {
            data[index++] = dcData[r][i];
          }
        }
      }
      for (i = 0; i < ecCount; i++) {
        for (r = 0; r < ecTotalBlocks; r++) {
          data[index++] = ecData[r][i];
        }
      }
      return data;
    }
    function createSymbol(data, version, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        let estimatedVersion = version;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version) {
        version = bestVersion;
      } else if (version < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      const dataBits = createData(version, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version >= 7) {
        setupVersionInfo(modules, version);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/utils.js
var require_utils2 = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/utils.js"(exports) {
    function hex2rgba(hex) {
      if (typeof hex === "number") {
        hex = hex.toString();
      }
      if (typeof hex !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c) {
          return [c, c];
        }));
      }
      if (hexCode.length === 6)
        hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions(options) {
      if (!options)
        options = {};
      if (!options.color)
        options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
      const size = qr.modules.size;
      const data = qr.modules.data;
      const scale = exports.getScale(size, opts);
      const symbolSize = Math.floor((size + opts.margin * 2) * scale);
      const scaledMargin = opts.margin * scale;
      const palette = [opts.color.light, opts.color.dark];
      for (let i = 0; i < symbolSize; i++) {
        for (let j = 0; j < symbolSize; j++) {
          let posDst = (i * symbolSize + j) * 4;
          let pxColor = opts.color.light;
          if (i >= scaledMargin && j >= scaledMargin && i < symbolSize - scaledMargin && j < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i - scaledMargin) / scale);
            const jSrc = Math.floor((j - scaledMargin) / scale);
            pxColor = palette[data[iSrc * size + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    var Utils = require_utils2();
    function clearCanvas(ctx, canvas, size) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style)
        canvas.style = {};
      canvas.height = size;
      canvas.width = size;
      canvas.style.height = size + "px";
      canvas.style.width = size + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size, size);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts)
        opts = {};
      const canvasEl = exports.render(qrData, canvas, opts);
      const type = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type, rendererOpts.quality);
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    var Utils = require_utils2();
    function getColorAttrib(color, attrib) {
      const alpha = color.a / 255;
      const str = attrib + '="' + color.hex + '"';
      return alpha < 1 ? str + " " + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x, y) {
      let str = cmd + x;
      if (typeof y !== "undefined")
        str += " " + y;
      return str;
    }
    function qrToPath(data, size, margin) {
      let path = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i = 0; i < data.length; i++) {
        const col = Math.floor(i % size);
        const row = Math.floor(i / size);
        if (!col && !newRow)
          newRow = true;
        if (data[i]) {
          lineLength++;
          if (!(i > 0 && col > 0 && data[i - 1])) {
            path += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size && data[i + 1])) {
            path += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path;
    }
    exports.render = function render(qrData, options, cb) {
      const opts = Utils.getOptions(options);
      const size = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size + opts.margin * 2;
      const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      const path = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size, opts.margin) + '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path + "</svg>\n";
      if (typeof cb === "function") {
        cb(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/browser.js
var require_browser = __commonJS({
  "node_modules/.pnpm/qrcode@1.5.4/node_modules/qrcode/lib/browser.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode2 = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb === "undefined") {
            cb = opts;
            opts = void 0;
          } else {
            cb = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            const data = QRCode2.create(text, opts);
            resolve(renderFunc(data, canvas, opts));
          } catch (e) {
            reject(e);
          }
        });
      }
      try {
        const data = QRCode2.create(text, opts);
        cb(null, renderFunc(data, canvas, opts));
      } catch (e) {
        cb(e);
      }
    }
    exports.create = QRCode2.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// src/modals/PreviewModal.ts
var import_obsidian5, QRCode, PreviewModal;
var init_PreviewModal = __esm({
  "src/modals/PreviewModal.ts"() {
    import_obsidian5 = require("obsidian");
    QRCode = __toESM(require_browser());
    init_utils();
    init_i18n();
    PreviewModal = class extends import_obsidian5.Modal {
      constructor(app, url) {
        super(app);
        this.url = url;
      }
      async onOpen() {
        const { contentEl } = this;
        this.setTitle("");
        const container = contentEl.createDiv();
        Object.assign(container.style, {
          maxWidth: "600px"
        });
        constructModalTitle(container, t("preview_modal.title"));
        const hint = container.createDiv({
          text: t("preview_modal.hint")
        });
        Object.assign(hint.style, {
          background: "var(--background-secondary)",
          padding: "0.8rem",
          borderRadius: "6px",
          margin: "0 0 1rem 0",
          wordBreak: "break-all",
          color: "var(--text-accent)"
        });
        const topContainer = container.createDiv();
        Object.assign(topContainer.style, {
          display: "flex",
          justifyContent: "space-between",
          margin: "0 0 1rem 0",
          background: "var(--background-primary)",
          padding: "var(--size-4-3)",
          borderRadius: "var(--radius-s)",
          border: "1px solid var(--background-modifier-border)"
        });
        const topContainerLeft = topContainer.createDiv();
        Object.assign(topContainerLeft.style, {
          flex: 1
        });
        const topContainerLeftTitle = topContainerLeft.createDiv({
          text: t("preview_modal.mobile.title")
        });
        topContainerLeftTitle.classList.add("setting-item-name");
        const topContainerLeftDesc = topContainerLeft.createDiv({
          text: t("preview_modal.mobile.desc")
        });
        topContainerLeftDesc.classList.add("setting-item-description");
        const topContainerRight = topContainer.createDiv();
        Object.assign(topContainerRight.style, {});
        const qrContainer = topContainerRight.createDiv({ cls: "quail-qr-container" });
        const canvas = document.createElement("canvas");
        qrContainer.appendChild(canvas);
        try {
          await QRCode.toCanvas(canvas, this.url, {
            width: 200,
            margin: 1
          });
        } catch (err) {
          qrContainer.createEl("p", { text: `Failed to generate QR code: ${err}` });
        }
        const buttonContainer = contentEl.createDiv();
        Object.assign(buttonContainer.style, {
          margin: "0",
          background: "var(--background-primary)",
          padding: "0.8rem 0.8rem 0 0.8rem",
          borderRadius: "var(--radius-s)",
          border: "1px solid var(--background-modifier-border)"
        });
        new import_obsidian5.Setting(buttonContainer).setName(t("preview_modal.desktop.title")).setDesc(t("preview_modal.desktop.desc")).addButton(
          (btn) => btn.setButtonText(t("preview_modal.preview")).setCta().onClick(() => {
            window.open(this.url, "_blank");
            this.close();
          })
        );
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// src/modals/index.ts
var init_modals = __esm({
  "src/modals/index.ts"() {
    init_ErrorModal();
    init_MessageModal();
    init_PublishResultModal();
    init_LoadingModal();
    init_PreviewModal();
  }
});

// src/util.ts
var import_obsidian6, util_default;
var init_util = __esm({
  "src/util.ts"() {
    import_obsidian6 = require("obsidian");
    util_default = {
      getImagePaths: function(markdownContent) {
        const imageRegex = /!\[(.*?)\]\((.*?)\)/g;
        const matches = [];
        let match = null;
        while (match = imageRegex.exec(markdownContent)) {
          if (match && match.length > 2) {
            const item = match[2];
            if (!item.startsWith("https://") && !item.startsWith("http://")) {
              matches.push(item);
            }
          }
        }
        return matches;
      },
      getMimeType: function(ext) {
        const mimeTypeMap = {
          "jpg": "image/jpeg",
          "jpeg": "image/jpeg",
          "png": "image/png",
          "gif": "image/gif",
          "bmp": "image/bmp",
          "webp": "image/webp",
          "svg": "image/svg+xml"
        };
        const mimeType = mimeTypeMap[ext.toLowerCase()];
        if (!mimeType) {
          return null;
        }
        return mimeType;
      },
      getActiveFileFrontmatter: async function(app) {
        const file = app.workspace.getActiveFile();
        if (file === null) {
          return { frontmatter: null, content: "" };
        }
        const text = await app.vault.cachedRead(file);
        let content = text;
        const frontmatter = {};
        const fc = app.metadataCache.getFileCache(file);
        const fmc = fc == null ? void 0 : fc.frontmatter;
        const fmp = fc == null ? void 0 : fc.frontmatterPosition;
        if (fmc && fmp && fmc !== void 0) {
          const end = fmp.end.line + 1;
          content = text.split("\n").slice(end).join("\n");
          for (const key in fmc) {
            if (Object.prototype.hasOwnProperty.call(fmc, key)) {
              const item = fmc[key];
              frontmatter[key] = item;
            }
          }
        }
        return {
          frontmatter,
          position: fmp,
          content
        };
      },
      getActiveFileMarkdown: async function(app) {
        const file = app.workspace.getActiveFile();
        if (file === null) {
          return "";
        }
        const text = await app.vault.cachedRead(file);
        let content = text;
        const fc = app.metadataCache.getFileCache(file);
        const fmc = fc == null ? void 0 : fc.frontmatter;
        const fmp = fc == null ? void 0 : fc.frontmatterPosition;
        if (fmc && fmp && fmc !== void 0) {
          const end = fmp.end.line + 1;
          content = text.split("\n").slice(end).join("\n");
        }
        return content;
      },
      getCoverImage: function(app, path) {
        const files = app.vault.getFiles();
        for (let ix = 0; ix < files.length; ix++) {
          const fd = files[ix];
          if (fd.path === path) {
            return fd;
          }
        }
        return null;
      },
      getImageFiles: function(app, currentMd) {
        var _a;
        const resolvedLinks = app.metadataCache.resolvedLinks;
        const files = [];
        for (const [mdFile, links] of Object.entries(resolvedLinks)) {
          if (currentMd.path === mdFile) {
            for (const [filePath, nr] of Object.entries(links)) {
              const ext = ((_a = filePath.split(".").pop()) == null ? void 0 : _a.toLocaleLowerCase()) || "";
              if (this.getMimeType(ext) !== null) {
                try {
                  const AttachFile = app.vault.getAbstractFileByPath(filePath);
                  if (AttachFile instanceof import_obsidian6.TFile) {
                    files.push(AttachFile);
                  }
                } catch (error) {
                  console.error(`quaily.getImageFiles: error: ${error}`);
                }
              }
            }
          }
        }
        return files;
      },
      getActiveFileContent: async function(app) {
        var _a;
        const file = app.workspace.getActiveFile();
        if (file) {
          const { frontmatter: fmc, content } = await this.getActiveFileFrontmatter(app);
          const coverImagePath = ((_a = fmc == null ? void 0 : fmc.cover_image_url) == null ? void 0 : _a.trim()) || "";
          const imgFiles = this.getImageFiles(app, file);
          const coverFile = this.getCoverImage(app, coverImagePath);
          imgFiles.push(coverFile);
          let coverImage = null;
          const images = [];
          for (let ix = 0; ix < imgFiles.length; ix++) {
            const fd = imgFiles[ix];
            if (fd) {
              const mimeType = this.getMimeType(fd.extension);
              if (mimeType === "") {
                continue;
              }
              const img = await app.vault.readBinary(fd);
              if (img.byteLength) {
                console.log(`quaily.getActiveFileContent: found: ${fd.path}, size: ${img.byteLength}`);
                const imgWrapper = {
                  pathname: fd.path,
                  name: fd.name,
                  data: img,
                  mimeType
                };
                if (fd.path === coverImagePath) {
                  coverImage = imgWrapper;
                }
                images.push(imgWrapper);
              }
            }
          }
          const title = file.name.replace(/\.md$/, "");
          return {
            title,
            content,
            frontmatter: {
              title: (fmc == null ? void 0 : fmc.title) || "",
              slug: (fmc == null ? void 0 : fmc.slug) || "",
              tags: (fmc == null ? void 0 : fmc.tags) || "",
              datetime: (fmc == null ? void 0 : fmc.datetime) || "",
              summary: (fmc == null ? void 0 : fmc.summary) || "",
              cover_image_url: (fmc == null ? void 0 : fmc.cover_image_url) || "",
              cover_image: coverImage
            },
            images,
            err: null
          };
        }
        return {
          title: "",
          content: "",
          frontmatter: null,
          images: [],
          err: "no active file"
        };
      },
      replaceImageUrls: function(content, oldUrls, newUrls) {
        if (oldUrls.length !== newUrls.length) {
          console.log("quaily.replaceImageUrls: the number of old and new urls do not match, return original content");
          return content;
        }
        const urlMap = {};
        for (let ix = 0; ix < oldUrls.length; ix++) {
          const oldUrl = oldUrls[ix];
          const newUrl = newUrls[ix];
          urlMap[oldUrl] = {
            used: false,
            newUrl
          };
        }
        const lines = content.split("\n");
        const newLines = [];
        const secondRoundLines = [];
        const allImageURLs = [];
        for (let ix = 0; ix < lines.length; ix++) {
          const line = lines[ix];
          let newLine = line;
          if (line.startsWith("![") && line.endsWith(")")) {
            const match = line.match(/!\[(.*?)\]\((.*?)\)/);
            if (match !== null && match.length > 1) {
              const oldUrl = decodeURIComponent(match[2]);
              if (urlMap[oldUrl]) {
                newLine = line.replace(`(${match[2]})`, `(${urlMap[oldUrl].newUrl})`);
                urlMap[oldUrl].used = true;
                allImageURLs.push(urlMap[oldUrl].newUrl);
              } else {
                console.log("quaily.replaceImageUrls: ignore image", oldUrl);
                allImageURLs.push(oldUrl);
              }
            }
          } else if (line.startsWith("![[") && line.endsWith("]]")) {
            const match = line.match(/!\[\[(.*?)\]\]/);
            if (match !== null && match.length > 0) {
              const oldUrl = decodeURIComponent(match[1]);
              const name = oldUrl.split("/").pop();
              if (urlMap[oldUrl]) {
                newLine = line.replace(`![[${match[1]}]]`, `![${name || oldUrl}](${urlMap[oldUrl].newUrl})`);
                urlMap[oldUrl].used = true;
                allImageURLs.push(urlMap[oldUrl].newUrl);
              } else {
                secondRoundLines.push({ line, index: ix });
              }
            }
          }
          newLines.push(newLine);
        }
        for (let ix = 0; ix < secondRoundLines.length; ix++) {
          const { index, line } = secondRoundLines[ix];
          let newLine = line;
          if (line.startsWith("![[") && line.endsWith("]]")) {
            const match = line.match(/!\[\[(.*?)\]\]/);
            if (match !== null && match.length > 0) {
              const name = decodeURIComponent(match[1]);
              let handled = false;
              for (const k in urlMap) {
                if (urlMap[k].used === false && k.endsWith(name)) {
                  newLine = line.replace(`![[${match[1]}]]`, `![${name}](${urlMap[k].newUrl})`);
                  handled = true;
                  allImageURLs.push(urlMap[k].newUrl);
                }
              }
              if (!handled) {
                console.log("quaily.replaceImageUrls:ignore image", name);
                allImageURLs.push(name);
              }
            }
          }
          newLines[index] = newLine;
        }
        return {
          content: newLines.join("\n"),
          image_urls: allImageURLs
        };
      }
    };
  }
});

// node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/.pnpm/dayjs@1.11.13/node_modules/dayjs/dayjs.min.js"(exports, module2) {
    !function(t2, e) {
      "object" == typeof exports && "undefined" != typeof module2 ? module2.exports = e() : "function" == typeof define && define.amd ? define(e) : (t2 = "undefined" != typeof globalThis ? globalThis : t2 || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t2 = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t3) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t3 % 100;
        return "[" + t3 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t3, e2, n2) {
        var r2 = String(t3);
        return !r2 || r2.length >= e2 ? t3 : "" + Array(e2 + 1 - r2.length).join(n2) + t3;
      }, v = { s: m, z: function(t3) {
        var e2 = -t3.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t3(e2, n2) {
        if (e2.date() < n2.date())
          return -t3(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t3) {
        return t3 < 0 ? Math.ceil(t3) || 0 : Math.floor(t3);
      }, p: function(t3) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t3] || String(t3 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t3) {
        return void 0 === t3;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t3) {
        return t3 instanceof _ || !(!t3 || !t3[p]);
      }, w = function t3(e2, n2, r2) {
        var i2;
        if (!e2)
          return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1)
            return t3(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t3, e2) {
        if (S(t3))
          return t3.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t3, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t3, e2) {
        return O(t3, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t3) {
          this.$L = w(t3.locale, null, true), this.parse(t3), this.$x = this.$x || t3.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t3) {
          this.$d = function(t4) {
            var e2 = t4.date, n2 = t4.utc;
            if (null === e2)
              return new Date(NaN);
            if (b.u(e2))
              return new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t3), this.init();
        }, m2.init = function() {
          var t3 = this.$d;
          this.$y = t3.getFullYear(), this.$M = t3.getMonth(), this.$D = t3.getDate(), this.$W = t3.getDay(), this.$H = t3.getHours(), this.$m = t3.getMinutes(), this.$s = t3.getSeconds(), this.$ms = t3.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t3, e2) {
          var n2 = O(t3);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t3, e2) {
          return O(t3) < this.startOf(e2);
        }, m2.isBefore = function(t3, e2) {
          return this.endOf(e2) < O(t3);
        }, m2.$g = function(t3, e2, n2) {
          return b.u(t3) ? this[e2] : this.set(n2, t3);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t3, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t3), l2 = function(t4, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t4) : new Date(n2.$y, e3, t4), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t4, e3) {
            return b.w(n2.toDate()[t4].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t3) {
          return this.startOf(t3, false);
        }, m2.$set = function(t3, e2) {
          var n2, o2 = b.p(t3), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t3, e2) {
          return this.clone().$set(t3, e2);
        }, m2.get = function(t3) {
          return this[b.p(t3)]();
        }, m2.add = function(r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function(t3) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t3 * r2)), l2);
          };
          if ($2 === c)
            return this.set(c, this.$M + r2);
          if ($2 === h)
            return this.set(h, this.$y + r2);
          if ($2 === a)
            return y2(1);
          if ($2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t2, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t3, e2) {
          return this.add(-1 * t3, e2);
        }, m2.format = function(t3) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || l;
          var r2 = t3 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t4, n3, i3, s3) {
            return t4 && (t4[n3] || t4(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t4) {
            return b.s(s2 % 12 || 12, t4, "0");
          }, $2 = f2 || function(t4, e3, n3) {
            var r3 = t4 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function(t4, r3) {
            return r3 || function(t5) {
              switch (t5) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t4) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t2;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t3, e2) {
          if (!t3)
            return this.$L;
          var n2 = this.clone(), r2 = w(t3, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t3) {
        k[t3[1]] = function(e2) {
          return this.$g(e2, t3[0], t3[1]);
        };
      }), O.extend = function(t3, e2) {
        return t3.$i || (t3(e2, _, O), t3.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t3) {
        return O(1e3 * t3);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }
});

// src/frontmatter.ts
function encodeQuote(str) {
  return str.replace(/"/g, '\\"');
}
var import_dayjs, frontmatter_default;
var init_frontmatter = __esm({
  "src/frontmatter.ts"() {
    import_dayjs = __toESM(require_dayjs_min());
    frontmatter_default = {
      suggestFrontmatter: async function(client, title, content, images) {
        const ret = {};
        const now = (0, import_dayjs.default)();
        ret["datetime"] = now.format("YYYY-MM-DD HH:mm");
        const resp = await client.generateFrontmatter(title, content, ["slug", "summary", "tags"]);
        ret["slug"] = encodeQuote(resp.slug);
        ret["summary"] = encodeQuote(resp.summary);
        ret["tags"] = encodeQuote(resp.tags);
        ret["cover_image_url"] = "";
        return {
          "slug": `${ret.slug}`,
          "datetime": `${ret.datetime}`,
          "summary": `${ret.summary}`,
          "tags": `${ret.tags}`,
          "cover_image_url": `${ret.cover_image_url}`
        };
      },
      emptyFrontmatter: function() {
        const now = (0, import_dayjs.default)();
        return {
          "slug": "INSERT_YOUR_SLUG_HERE",
          "datetime": `${now.format("YYYY-MM-DD HH:mm")}`,
          "summary": "INSERT_YOUR_SUMMARY_HERE",
          "tags": "INSERT_YOUR_TAGS_HERE",
          "theme": "light",
          "cover_image_url": ""
        };
      },
      replaceFields: function(frontmatter) {
        const ret = Object.assign({}, frontmatter);
        const now = (0, import_dayjs.default)().format("YYYY-MM-DDTHH:mm:ssZ");
        ret.summary = frontmatter.summary || frontmatter.description || frontmatter.subtitle || "";
        ret.datetime = frontmatter.datetime || frontmatter.date || now;
        ret.cover_image_url = frontmatter.cover_image_url || frontmatter.cover || "";
        return ret;
      },
      verifyFrontmatter: function(frontmatter) {
        const keys = {};
        if (!frontmatter.slug) {
          return { verified: false, reason: "`slug` is required" };
        }
        for (const key in frontmatter) {
          if (Object.prototype.hasOwnProperty.call(frontmatter, key)) {
            const value = frontmatter[key];
            const obj = { validated: false, reason: "" };
            switch (key) {
              case "slug":
                if (typeof value === "string") {
                  if (/^[a-zA-Z0-9-_]+$/.test(value)) {
                    obj.validated = true;
                  } else {
                    obj.reason = "`slug` can only contain english, number, dash and underline";
                  }
                } else {
                  obj.reason = "`slug` must be string";
                }
                keys[key] = obj;
                break;
              case "title":
                if (typeof value === "string") {
                  obj.validated = true;
                } else {
                  obj.reason = "`title` must be string";
                }
                keys[key] = obj;
                break;
              case "tags": {
                console.log(typeof value, value.constructor.name);
                const re = /\s*([^\s,]+)\s*(?:,\s*|$)/g;
                if (typeof value === "string") {
                  const trimed = value.trim();
                  if (trimed.length !== 0) {
                    if (re.test(trimed)) {
                      obj.validated = true;
                    } else {
                      obj.reason = "`tags` must be string, split by comma";
                    }
                  } else {
                    obj.validated = true;
                  }
                } else if (Array.isArray(value)) {
                  obj.validated = true;
                } else {
                  obj.reason = "`tags` must be string";
                }
                keys[key] = obj;
                break;
              }
              case "datetime":
                if (typeof value === "string") {
                  obj.validated = true;
                } else {
                  obj.reason = "`datetime` must be date string";
                }
                keys[key] = obj;
                break;
              case "summary":
                if (typeof value === "string") {
                  obj.validated = true;
                } else {
                  obj.reason = "`summary` must be string";
                }
                keys[key] = obj;
                break;
              case "cover_image_url":
                if (typeof value === "string") {
                  obj.validated = true;
                } else {
                  obj.reason = "`cover_image_url` must be string";
                }
                keys[key] = obj;
                break;
              default:
                break;
            }
          }
        }
        for (const key in keys) {
          if (Object.prototype.hasOwnProperty.call(keys, key)) {
            const item = keys[key];
            if (!item.validated) {
              return item;
            }
          }
        }
        return { verified: true, reason: "" };
      },
      formalizeFrontmatter: function(frontmatter, text) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        const ret = {};
        if (((_a = frontmatter == null ? void 0 : frontmatter.slug) == null ? void 0 : _a.trim().length) === 0) {
          return false;
        }
        ret.slug = frontmatter.slug.trim();
        if (((_b = frontmatter == null ? void 0 : frontmatter.datetime) == null ? void 0 : _b.trim().length) !== 0) {
          try {
            ret.datetime = (0, import_dayjs.default)(frontmatter.datetime.trim()).format("YYYY-MM-DDTHH:mm:ssZ");
          } catch (e) {
            ret.datetime = (0, import_dayjs.default)().format("YYYY-MM-DDTHH:mm:ssZ");
          }
        } else {
          ret.datetime = (0, import_dayjs.default)().format("YYYY-MM-DDTHH:mm:ssZ");
        }
        ret.summary = ((_c = frontmatter.summary) == null ? void 0 : _c.trim()) || "";
        if (((_d = frontmatter == null ? void 0 : frontmatter.cover_image_url) == null ? void 0 : _d.trim().length) !== 0) {
          ret.cover_image_url = ((_e = frontmatter.cover_image_url) == null ? void 0 : _e.trim()) || "";
        }
        if ((frontmatter == null ? void 0 : frontmatter.tags.constructor.name) === "Array") {
          if ((frontmatter == null ? void 0 : frontmatter.tags.length) !== 0) {
            ret.tags = frontmatter.tags.join(",") || "";
          }
          const tags = frontmatter.tags.map((x) => {
            if (typeof x === "string") {
              return x.trim();
            }
            return "";
          }).filter((x) => x.length !== 0);
          ret.tags = tags.join(",") || "";
        } else if ((frontmatter == null ? void 0 : frontmatter.tags.constructor.name) === "String") {
          if (((_f = frontmatter == null ? void 0 : frontmatter.tags) == null ? void 0 : _f.trim().length) !== 0) {
            ret.tags = ((_g = frontmatter.tags) == null ? void 0 : _g.trim()) || "";
          }
        } else {
          ret.tags = "";
        }
        if (((_h = frontmatter == null ? void 0 : frontmatter.title) == null ? void 0 : _h.trim().length) !== 0) {
          ret.title = ((_i = frontmatter.title) == null ? void 0 : _i.trim()) || "";
        }
        return ret;
      }
    };
  }
});

// src/actions/aigen.ts
var aigen, aigen_default;
var init_aigen = __esm({
  "src/actions/aigen.ts"() {
    init_util();
    init_frontmatter();
    init_modals();
    init_i18n();
    aigen = function(app, auxiliaClient, settings) {
      let name = english("actions.ai_gen_metadata");
      if (!settings.useEnglishCmds) {
        name = t("actions.ai_gen_metadata");
      }
      return {
        id: "ai-gen-metadata",
        name,
        callback: async () => {
          const content = await util_default.getActiveFileMarkdown(app);
          const file = app.workspace.getActiveFile();
          const loadingModal = new LoadingModal(app);
          loadingModal.open();
          if (file) {
            const title = file.name.replace(/\.md$/, "");
            const fmc = await frontmatter_default.suggestFrontmatter(auxiliaClient, title, content, []);
            const proc = (frontmatter) => {
              if (file) {
                try {
                  for (const key in fmc) {
                    if (Object.prototype.hasOwnProperty.call(fmc, key)) {
                      if (key === "summary" || key === "tags") {
                        frontmatter[key] = fmc[key];
                      } else {
                        if (frontmatter[key] === null || frontmatter[key] === void 0 || frontmatter[key] === "") {
                          frontmatter[key] = fmc[key];
                        }
                      }
                    }
                  }
                } catch (e) {
                  new ErrorModal(app, e).open();
                } finally {
                  loadingModal.close();
                }
              }
            };
            app.fileManager.processFrontMatter(file, proc);
          } else {
            loadingModal.close();
          }
        }
      };
    };
    aigen_default = aigen;
  }
});

// src/actions/save.ts
function save(app, client, auxiliaClient, settings) {
  let name = english("actions.save");
  if (!settings.useEnglishCmds) {
    name = t("actions.save");
  }
  return {
    id: "save",
    name,
    callback: async () => {
      const loadingModal = new LoadingModal(app);
      loadingModal.open();
      let pt = null;
      try {
        pt = await savePost(app, client, auxiliaClient, settings);
      } catch (e) {
        new ErrorModal(app, e).open();
        loadingModal.close();
        return;
      } finally {
        loadingModal.close();
      }
      const slug = (pt == null ? void 0 : pt.slug) || "";
      if (slug) {
        if ((pt == null ? void 0 : pt.published_at) !== null) {
          const payload = {
            title: pt.title,
            summary: pt.summary,
            coverImageUrl: pt.cover_image_url,
            url: `https://quaily.com/${settings.listSlug}/p/${slug}`
          };
          new PublishResultModal(app, client, payload).open();
        } else {
          new import_obsidian7.Notice(t("notices.post_saved"));
        }
      }
    }
  };
}
var import_obsidian7;
var init_save = __esm({
  "src/actions/save.ts"() {
    import_obsidian7 = require("obsidian");
    init_modals();
    init_actions();
    init_i18n();
  }
});

// src/actions/preview.ts
function preview(app, client, auxiliaClient, settings) {
  let name = english("actions.preview");
  if (!settings.useEnglishCmds) {
    name = t("actions.preview");
  }
  return {
    id: "quail-preview",
    name,
    callback: async () => {
      const loadingModal = new LoadingModal(app);
      loadingModal.open();
      try {
        const activeFile = app.workspace.getActiveFile();
        if (!activeFile) {
          new import_obsidian8.Notice("No active file");
          return;
        }
        const { savePost: savePost2 } = await Promise.resolve().then(() => (init_actions(), actions_exports));
        const post = await savePost2(app, client, auxiliaClient, settings);
        if (!post || !post.id || !post.list_id) {
          new import_obsidian8.Notice("Failed to save post or get post details");
          return;
        }
        const origin = window.location.origin;
        const resp = await client.issueEphemeralToken(origin);
        if (!resp || !resp.ephemeral_token) {
          throw new Error("Failed to generate preview token");
        }
        if (resp.ephemeral_token) {
          const previewUrl = client.getPostPreviewUrl(post.list_id, post.id, resp.ephemeral_token);
          new PreviewModal(app, previewUrl).open();
        }
      } catch (error) {
        new ErrorModal(app, error).open();
      } finally {
        loadingModal.close();
      }
    }
  };
}
var import_obsidian8;
var init_preview = __esm({
  "src/actions/preview.ts"() {
    import_obsidian8 = require("obsidian");
    init_modals();
    init_modals();
    init_i18n();
  }
});

// src/actions/publish.ts
function publish(app, client, auxiliaClient, settings) {
  let name = english("actions.publish");
  if (!settings.useEnglishCmds) {
    name = t("actions.publish");
  }
  return {
    id: "quail-publish",
    name,
    callback: async () => {
      const file = app.workspace.getActiveFile();
      if (file !== null) {
        const loadingModal = new LoadingModal(app);
        loadingModal.open();
        let pt = null;
        try {
          pt = await savePost(app, client, auxiliaClient, settings);
        } catch (e) {
          new ErrorModal(app, e).open();
          loadingModal.close();
          return;
        }
        try {
          pt = await client.publishPost(settings.listID, pt.slug);
        } catch (e) {
          new ErrorModal(app, e).open();
          loadingModal.close();
          return;
        } finally {
          loadingModal.close();
        }
        const slug = pt.slug || "";
        if (slug) {
          const viewUrl = `https://quaily.com/${settings.listSlug}/p/${slug}`;
          new PublishResultModal(app, client, {
            url: viewUrl,
            title: pt.title,
            summary: pt.summary,
            coverImageUrl: pt.cover_image_url
          }).open();
        } else {
          new ErrorModal(app, new Error("resp.slug is empty.")).open();
        }
      }
    }
  };
}
var init_publish = __esm({
  "src/actions/publish.ts"() {
    init_modals();
    init_actions();
    init_i18n();
  }
});

// src/actions/unpublish.ts
function unpublish(app, client, settings) {
  let name = english("actions.unpublish");
  if (!settings.useEnglishCmds) {
    name = t("actions.unpublish");
  }
  return {
    id: "unpublish",
    name,
    callback: async () => {
      const { frontmatter, err } = await util_default.getActiveFileContent(app);
      if (err != null) {
        new ErrorModal(app, new Error(err)).open();
        return;
      }
      const loadingModal = new LoadingModal(app);
      loadingModal.open();
      try {
        await client.unpublishPost(settings.listID, frontmatter == null ? void 0 : frontmatter.slug);
        new import_obsidian9.Notice(t("notices.unpublish_success"));
      } catch (e) {
        loadingModal.close();
        new ErrorModal(app, e).open();
      } finally {
        loadingModal.close();
      }
    }
  };
}
var import_obsidian9;
var init_unpublish = __esm({
  "src/actions/unpublish.ts"() {
    import_obsidian9 = require("obsidian");
    init_modals();
    init_util();
    init_i18n();
  }
});

// src/actions/send.ts
function send(app, client, settings) {
  let name = english("actions.send");
  if (!settings.useEnglishCmds) {
    name = t("actions.send");
  }
  return {
    id: "deliver",
    name,
    callback: async () => {
      const { frontmatter, err } = await util_default.getActiveFileContent(app);
      if (err != null) {
        new ErrorModal(app, new Error(err.toString())).open();
        return;
      }
      const loadingModal = new LoadingModal(app);
      loadingModal.open();
      try {
        await client.deliverPost(settings.listID, frontmatter == null ? void 0 : frontmatter.slug);
        new MessageModal(app, {
          title: t("message_modal.send_post.title"),
          message: t("message_modal.send_post.desc"),
          icon: "\u{1F680}"
        }).open();
      } catch (e) {
        loadingModal.close();
        new ErrorModal(app, e).open();
        return;
      } finally {
        loadingModal.close();
      }
    }
  };
}
var init_send = __esm({
  "src/actions/send.ts"() {
    init_modals();
    init_util();
    init_i18n();
  }
});

// src/actions/set-channel.ts
function setChannel(app, settings, saveSettings) {
  let name = english("actions.set_channel");
  if (!settings.useEnglishCmds) {
    name = t("actions.set_channel");
  }
  return {
    id: "quail-set-channel",
    name,
    callback: async () => {
      try {
        const lists = settings.lists;
        if (!lists || lists.length === 0) {
          new MessageModal(app, {
            title: t("message_modal.no_channels_found.title"),
            message: t("message_modal.no_channels_found.desc"),
            icon: "\u26A0\uFE0F",
            iconColor: "orange"
          }).open();
          return;
        }
        const channelList = lists.map((list) => ({
          title: list.title,
          id: list.id
        }));
        new ChannelSuggestModal(app, channelList, async (item) => {
          for (let ix = 0; ix < lists.length; ix++) {
            if (lists[ix].id === item.id) {
              settings.listID = lists[ix].id;
              settings.listSlug = lists[ix].slug;
              await saveSettings();
              new import_obsidian10.Notice(t("notices.set_channel_success", { title: item.title }));
              return;
            }
          }
        }).open();
      } catch (e) {
        new ErrorModal(app, e).open();
      }
    }
  };
}
var import_obsidian10, ChannelSuggestModal;
var init_set_channel = __esm({
  "src/actions/set-channel.ts"() {
    import_obsidian10 = require("obsidian");
    init_modals();
    init_i18n();
    ChannelSuggestModal = class extends import_obsidian10.SuggestModal {
      constructor(app, channelList, onSelect) {
        super(app);
        this.channelList = channelList;
        this.onSelect = onSelect;
        this.setPlaceholder(t("actions.set_channel.select_channel"));
      }
      getSuggestions() {
        return this.channelList;
      }
      renderSuggestion(item, el) {
        el.createEl("div", { text: item.title });
      }
      onChooseSuggestion(item) {
        this.onSelect(item);
      }
    };
  }
});

// src/actions/insert-metadata.ts
function insertMetadata(app, auxiliaClient, settings) {
  let name = english("actions.insert_metadata");
  if (!settings.useEnglishCmds) {
    name = t("actions.insert_metadata");
  }
  return {
    id: "insert-metadata",
    name,
    callback: async () => {
      const file = app.workspace.getActiveFile();
      if (file) {
        const proc = (frontmatter) => {
          if (frontmatter === null || Object.values(frontmatter).length === 0) {
            const fmc = frontmatter_default.emptyFrontmatter();
            for (const key in fmc) {
              if (Object.prototype.hasOwnProperty.call(fmc, key)) {
                frontmatter[key] = fmc[key];
              }
            }
          } else {
            const modal = new MessageModal(app, {
              title: t("message_modal.metadata_exists.title"),
              message: t("message_modal.metadata_exists.desc"),
              icon: "\u{1F514}",
              iconColor: "orange",
              actions: [{
                text: t("common.generate"),
                primary: true,
                click: (dialog) => {
                  aigen_default(app, auxiliaClient, settings).callback();
                  dialog.close();
                }
              }, {
                text: t("common.cancel"),
                close: true
              }]
            });
            modal.open();
          }
        };
        app.fileManager.processFrontMatter(file, proc);
      }
    }
  };
}
var init_insert_metadata = __esm({
  "src/actions/insert-metadata.ts"() {
    init_modals();
    init_frontmatter();
    init_i18n();
    init_aigen();
  }
});

// src/actions/index.ts
var actions_exports = {};
__export(actions_exports, {
  getActions: () => getActions,
  savePost: () => savePost
});
async function uploadAttachment(client, image) {
  const formData = new FormData();
  const picArray = new Uint8Array(image.data).buffer;
  formData.append("file", new Blob([picArray], { type: image.mimeType }), image.name);
  const resp = await client.uploadAttachment(formData);
  return resp.view_url;
}
async function arrangeArticle(app, client, auxiliaClient, settings) {
  const { title, content, frontmatter: frontmatterO, images, err } = await util_default.getActiveFileContent(app);
  if (err != null) {
    new ErrorModal(app, new Error(err.toString())).open();
    return { frontmatter: null, content: null };
  }
  const frontmatter = frontmatter_default.replaceFields(frontmatterO);
  const { verified, reason } = frontmatter_default.verifyFrontmatter(frontmatter);
  if (!verified) {
    new MessageModal(app, {
      title: t("message_modal.failed_to_verify_meta.title"),
      message: reason,
      icon: "\u{1F916}",
      iconColor: "orange",
      actions: [{
        text: t("common.generate"),
        primary: true,
        click: (dialog) => {
          aigen_default(app, auxiliaClient, settings).callback();
          dialog.close();
        }
      }, {
        text: t("common.cancel"),
        close: true
      }]
    }).open();
    return { frontmatter: null, content: null };
  }
  const oldUrls = [];
  const newUrls = [];
  for (let ix = 0; ix < images.length; ix++) {
    const img = images[ix];
    if (img) {
      try {
        const viewUrl = await uploadAttachment(client, img);
        newUrls.push(viewUrl);
        oldUrls.push(img.pathname);
        console.log(`quaily.upload image: ${img.pathname}, new url: ${viewUrl}`);
      } catch (e) {
        console.log("quaily.upload image error: ", e);
        new ErrorModal(app, new Error(e)).open();
        return { frontmatter: null, content: null };
      }
    }
  }
  if (frontmatter == null ? void 0 : frontmatter.cover_image) {
    try {
      const viewUrl = await uploadAttachment(client, frontmatter.cover_image);
      frontmatter.cover_image_url = viewUrl;
      console.log(`quaily.upload cover: ${frontmatter.cover_image.pathname}, new url: ${viewUrl}`);
    } catch (e) {
      console.log("quaily.upload cover error: ", e);
      new ErrorModal(app, new Error(e)).open();
      return { frontmatter: null, content: null };
    }
  }
  const ret = util_default.replaceImageUrls(content, oldUrls, newUrls);
  const newContent = ret.content.trim() || "";
  const imageUrls = ret.image_urls.filter((url) => {
    return url.startsWith("https://") || url.startsWith("http://") || url.startsWith("//");
  });
  const fmt = frontmatter_default.formalizeFrontmatter(frontmatter, newContent);
  if (frontmatter.cover_image === null && frontmatter.cover_image_url === "") {
    if (settings.useFirstImageAsCover && imageUrls.length > 0) {
      fmt.cover_image_url = imageUrls[0];
    }
  }
  return {
    title,
    frontmatter: fmt,
    content: newContent
  };
}
async function savePost(app, client, auxiliaClient, settings) {
  const { title, frontmatter, content } = await arrangeArticle(app, client, auxiliaClient, settings);
  if (content == null || title == null) {
    return;
  }
  const checkMetadata = (fm) => {
    const fields = ["slug", "summary", "tags"];
    for (let i = 0; i < fields.length; i++) {
      if (fm[fields[i]] === "" || fm[fields[i]] === null || fm[fields[i]] === void 0) {
        return false;
      }
    }
    return true;
  };
  if (!checkMetadata(frontmatter)) {
    const file = app.workspace.getActiveFile();
    if (file) {
      const fmc = await frontmatter_default.suggestFrontmatter(auxiliaClient, title, content, []);
      const proc = (frontmatter2) => {
        if (file) {
          const loadingModal = new LoadingModal(app);
          loadingModal.open();
          try {
            for (const key in fmc) {
              if (Object.prototype.hasOwnProperty.call(fmc, key)) {
                if (frontmatter2[key] === "" || frontmatter2[key] === null || frontmatter2[key] === void 0) {
                  console.log(`quaily.savePost: update metadata: ${key} = ${fmc[key]}`);
                  frontmatter2[key] = fmc[key];
                }
              }
            }
          } catch (e) {
            loadingModal.close();
            new ErrorModal(app, e).open();
          } finally {
            loadingModal.close();
          }
        }
      };
      app.fileManager.processFrontMatter(file, proc);
    } else {
      return;
    }
  }
  let newContent = content;
  if (!settings.strictLineBreaks) {
    newContent = newContent.replace(/\n/g, "\n\n");
  }
  const payload = {
    slug: frontmatter.slug,
    title: frontmatter.title || title,
    cover_image_url: frontmatter.cover_image_url,
    summary: frontmatter.summary,
    content: newContent,
    tags: frontmatter.tags,
    theme: frontmatter.theme,
    first_published_at: frontmatter.datetime
  };
  let resp = null;
  try {
    resp = await client.createPost(settings.listID, payload);
  } catch (e) {
    new ErrorModal(app, e).open();
    return;
  } finally {
  }
  return resp;
}
function getActions(plugin) {
  const app = plugin.app;
  const settings = plugin.settings;
  const client = plugin.client;
  const auxiliaClient = plugin.auxiliaClient;
  const loginAction = [
    {
      id: "quail-login",
      name: "Login",
      callback: async () => {
        await plugin.login();
      }
    }
  ];
  if (settings.accessToken === "" || settings.refreshToken === "" || settings.tokenExpiry === "") {
    return loginAction;
  }
  return [
    publish(app, client, auxiliaClient, settings),
    unpublish(app, client, settings),
    save(app, client, auxiliaClient, settings),
    preview(app, client, auxiliaClient, settings),
    send(app, client, settings),
    aigen_default(app, auxiliaClient, settings),
    setChannel(app, settings, plugin.saveSettings.bind(plugin)),
    insertMetadata(app, auxiliaClient, settings)
  ];
}
var init_actions = __esm({
  "src/actions/index.ts"() {
    init_modals();
    init_util();
    init_frontmatter();
    init_aigen();
    init_save();
    init_preview();
    init_publish();
    init_unpublish();
    init_send();
    init_set_channel();
    init_insert_metadata();
    init_i18n();
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => QuailPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian12 = require("obsidian");
init_actions();

// node_modules/.pnpm/quail-js@0.3.18/node_modules/quail-js/dist/quail.min.js
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1)
      throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y, t2, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done)
          return t2;
        if (y = 0, t2)
          op = [op[0] & 2, t2.value];
        switch (op[0]) {
          case 0:
          case 1:
            t2 = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t2[1]) {
              _.label = t2[1];
              t2 = op;
              break;
            }
            if (t2 && _.label < t2[2]) {
              _.label = t2[2];
              _.ops.push(op);
              break;
            }
            if (t2[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t2 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
async function sendRequest(url, method, headers, body) {
  headers["Content-Type"] = "application/json";
  const resp = await fetch(url, {
    method,
    headers,
    body: body ? JSON.stringify(body) : null
  });
  const json = await resp.json();
  if (json.code) {
    console.error("[quailjs.request] client error", json.code, json.message || json.msg);
    throw new Error(`${json.code} | ${json.message || json.msg} | ${method} ${url}`);
  }
  return json.data;
}
async function sendRequestFormData(url, headers, body) {
  const resp = await fetch(url, {
    method: "POST",
    headers,
    body: body || null
  });
  const json = await resp.json();
  if (json.code) {
    console.error("[quailjs.request] client error", json.code, json.message || json.msg);
    throw new Error(`${json.code} | ${json.message || json.msg} | POST ${url}`);
  }
  return json.data || { code: json == null ? void 0 : json.code, message: json == null ? void 0 : json.message };
}
function getAccessTokenFromEnv() {
  let token = "";
  const auth2 = localStorage.getItem("auth");
  if (auth2) {
    try {
      const authObj = JSON.parse(auth2);
      token = authObj.access_token || authObj.token || "";
    } catch (e) {
      token = "";
    }
  }
  if (token === "") {
    token = window._access_token || "";
  }
  return token;
}
var Client = (
  /** @class */
  function() {
    function Client2(opts) {
      this.apibase = "";
      this.apikey = "";
      this.access_token = "";
      this.debug = false;
      this.apikey = opts.apikey || "";
      this.access_token = opts.access_token || "";
      this.apibase = opts.apibase || "https://api.quail.ink";
      this.debug = opts.debug || false;
    }
    Client2.prototype.getAccessToken = function() {
      var token = this.access_token;
      if (token === "") {
        token = getAccessTokenFromEnv();
      }
      return token;
    };
    Client2.prototype.request = function(url, method, body) {
      return __awaiter(this, void 0, void 0, function() {
        var headers, token;
        return __generator(this, function(_a) {
          url = this.apibase + url;
          headers = {
            "Content-Type": "application/json"
          };
          token = this.getAccessToken();
          if (token) {
            headers["Authorization"] = "Bearer ".concat(token);
          }
          if (this.apikey) {
            headers["X-QUAIL-KEY"] = this.apikey;
          }
          if (this.debug) {
            console.log("request: ".concat(method, " ").concat(url));
            console.log("- headers", headers);
            console.log("- body", body);
          }
          return [2, sendRequest(url, method, headers, body)];
        });
      });
    };
    Client2.prototype.requestFormData = function(url, body) {
      return __awaiter(this, void 0, void 0, function() {
        var headers, token;
        return __generator(this, function(_a) {
          url = this.apibase + url;
          headers = {};
          token = this.getAccessToken();
          if (token) {
            headers["Authorization"] = "Bearer ".concat(token);
          }
          if (this.apikey) {
            headers["X-QUAIL-KEY"] = this.apikey;
          }
          if (this.debug) {
            console.log("request: POST ".concat(url));
            console.log("- headers", headers);
            console.log("- body", body);
          }
          return [2, sendRequestFormData(url, headers, body)];
        });
      });
    };
    Client2.prototype.getAuthCode = function(email, ctoken, scene) {
      if (scene === void 0) {
        scene = "login";
      }
      var lang = navigator.language;
      if (lang.length > 2) {
        lang = lang.substring(0, 2);
      }
      return this.request("/auth/code", "POST", {
        email,
        lang,
        scene,
        "challenge-action": "request_auth_code",
        "challenge-token": ctoken
      });
    };
    Client2.prototype.login = function(email, code) {
      var lang = navigator.language;
      if (lang.length > 2) {
        lang = lang.substring(0, 2);
      }
      return this.request("/auth/login", "POST", {
        "method": "email_code",
        "email": email,
        "code": code,
        "lang": lang
      });
    };
    Client2.prototype.issueEphemeralToken = function(origin) {
      return this.request("/auth/ephemeral?origin=".concat(origin), "POST", null);
    };
    Client2.prototype.exchangeAccessTokenWithEphemeral = function(token) {
      return this.request("/auth/ephemeral/exchange?token=".concat(token), "POST", null);
    };
    Client2.prototype.getConfig = function() {
      return this.request("/c", "GET", null);
    };
    Client2.prototype.getMe = function() {
      return this.request("/users/me", "GET", null);
    };
    Client2.prototype.updateMe = function(profile) {
      return this.request("/users/me", "PUT", profile);
    };
    Client2.prototype.updateMeEmail = function(email, code) {
      return this.request("/users/me/email", "PUT", {
        email,
        code
      });
    };
    Client2.prototype.updateMeOptions = function(options) {
      return this.request("/users/me/options", "PUT", {
        options
      });
    };
    Client2.prototype.getUser = function(user_id) {
      return this.request("/users/".concat(user_id), "GET", null);
    };
    Client2.prototype.getUserLists = function(user_id) {
      return this.request("/users/".concat(user_id, "/lists"), "GET", null);
    };
    Client2.prototype.subscribe = function(list_id, email, ctoken) {
      return this.request("/subscriptions/".concat(list_id), "POST", {
        email,
        "challenge-action": "subscribe",
        "challenge-token": ctoken
      });
    };
    Client2.prototype.batchAddSubscribers = function(list_id, members, ctoken) {
      return this.request("/subscriptions/".concat(list_id, "/add-members"), "POST", {
        "challenge-action": "subscribe",
        "challenge-token": ctoken,
        "members": members
      });
    };
    Client2.prototype.updateSubscriber = function(list_id, member_id, payload) {
      return this.request("/subscriptions/".concat(list_id, "/members/").concat(member_id), "PUT", payload);
    };
    Client2.prototype.deleteSubscriber = function(list_id, member_id) {
      return this.request("/subscriptions/".concat(list_id, "/members/").concat(member_id), "DELETE", null);
    };
    Client2.prototype.getMySubscriptions = function() {
      return this.request("/subscriptions", "GET", null);
    };
    Client2.prototype.getMySubscription = function(list_id) {
      return this.request("/subscriptions/".concat(list_id, "/rel"), "GET", null);
    };
    Client2.prototype.subscribeNoChallenge = function(list_id) {
      return this.request("/subscriptions/".concat(list_id, "/no-challenge"), "POST", null);
    };
    Client2.prototype.unsubscribe = function(list_id, trace_id) {
      if (trace_id === void 0) {
        trace_id = "";
      }
      return this.request("/subscriptions/".concat(list_id), "DELETE", { trace_id });
    };
    Client2.prototype.getUnsubscribeOpponent = function(trace_id) {
      return this.request("/subscriptions/opponent?trace_id=".concat(trace_id), "GET", null);
    };
    Client2.prototype.getListPosts = function(list_id, offset, limit, pub, sort) {
      if (offset === void 0) {
        offset = 0;
      }
      if (limit === void 0) {
        limit = 16;
      }
      if (pub === void 0) {
        pub = false;
      }
      if (sort === void 0) {
        sort = "";
      }
      var url = "/lists/".concat(list_id, "/posts?offset=").concat(offset, "&limit=").concat(limit);
      if (pub) {
        url += "&public=1";
      }
      if (sort) {
        url += "&sort=".concat(sort);
      }
      return this.request(url, "GET", null);
    };
    Client2.prototype.getListDeliveryTasks = function(list_id, offset, limit) {
      if (offset === void 0) {
        offset = 0;
      }
      if (limit === void 0) {
        limit = 10;
      }
      return this.request("/lists/".concat(list_id, "/delivery?offset=").concat(offset, "&limit=").concat(limit), "GET", null);
    };
    Client2.prototype.getListDeliveryTask = function(list_id, task_id) {
      return this.request("/lists/".concat(list_id, "/delivery/").concat(task_id), "GET", null);
    };
    Client2.prototype.cancelScheduledDeliveryTask = function(list_id, task_id) {
      return this.request("/lists/".concat(list_id, "/delivery/").concat(task_id, "/cancel"), "PUT", null);
    };
    Client2.prototype.getPinnedPosts = function(list_id) {
      return this.request("/lists/".concat(list_id, "/pinned"), "GET", null);
    };
    Client2.prototype.pinPosts = function(list_id, ids) {
      return this.request("/lists/".concat(list_id, "/pinned"), "PUT", { ids });
    };
    Client2.prototype.getPost = function(list_id, post_id) {
      return this.request("/lists/".concat(list_id, "/posts/").concat(post_id), "GET", null);
    };
    Client2.prototype.deletePost = function(list_id, post_id) {
      return this.request("/lists/".concat(list_id, "/posts/").concat(post_id), "DELETE", null);
    };
    Client2.prototype.getPostContent = function(list_id, post_id) {
      return this.request("/lists/".concat(list_id, "/posts/").concat(post_id, "/content"), "GET", null);
    };
    Client2.prototype.searchPosts = function(q, list, offset) {
      if (list === void 0) {
        list = 0;
      }
      if (offset === void 0) {
        offset = 0;
      }
      return this.request("/posts/search", "POST", {
        q,
        list,
        offset
      });
    };
    Client2.prototype.createList = function(payload) {
      return this.request("/lists", "POST", payload);
    };
    Client2.prototype.getLists = function(user_id) {
      return this.request("/users/".concat(user_id, "/lists"), "GET", null);
    };
    Client2.prototype.getList = function(list_id) {
      return this.request("/lists/".concat(list_id), "GET", null);
    };
    Client2.prototype.getListByDomain = function(domain) {
      return this.request("/lists/domains/".concat(domain), "GET", null);
    };
    Client2.prototype.getListMetrics = function(list_id) {
      return this.request("/lists/".concat(list_id, "/metrics"), "GET", null);
    };
    Client2.prototype.updateList = function(list_id, payload) {
      return this.request("/lists/".concat(list_id), "PUT", payload);
    };
    Client2.prototype.updateListBulletin = function(list_id, payload) {
      return this.request("/lists/".concat(list_id, "/bulletin"), "PUT", payload);
    };
    Client2.prototype.updateListChannel = function(list_id, payload) {
      return this.request("/lists/".concat(list_id, "/channel"), "PUT", payload);
    };
    Client2.prototype.getListChannel = function(list_id) {
      return this.request("/lists/".concat(list_id, "/channel"), "GET", null);
    };
    Client2.prototype.createListChannelLineKeys = function(list_id) {
      return this.request("/lists/".concat(list_id, "/channel/line/keys"), "POST", null);
    };
    Client2.prototype.getTwitterAuthUrl = function(list_id) {
      return this.request("/twitter/authorize?list=".concat(list_id || ""), "GET", null);
    };
    Client2.prototype.updateListAnalytics = function(list_id, payload) {
      return this.request("/lists/".concat(list_id, "/analytics"), "PUT", payload);
    };
    Client2.prototype.updateListEmailSettings = function(list_id, payload) {
      if (payload.email_signature_text.length > 2048) {
        payload.email_signature_text = payload.email_signature_text.substring(0, 2048);
      }
      if (payload.email_onboarding_text.length > 2048) {
        payload.email_onboarding_text = payload.email_onboarding_text.substring(0, 2048);
      }
      return this.request("/lists/".concat(list_id, "/email_settings"), "PUT", {
        "email_channel_enabled": payload.email_channel_enabled,
        "email_deny_list": payload.email_deny_list || [],
        "email_onboarding_text": payload.email_onboarding_text || "",
        "email_signature_text": payload.email_signature_text || ""
      });
    };
    Client2.prototype.updateListSlug = function(list_id, slug) {
      return this.request("/lists/".concat(list_id, "/slug?slug=").concat(slug), "PUT", null);
    };
    Client2.prototype.updateListDomain = function(list_id, payload) {
      return this.request("/lists/".concat(list_id, "/domain"), "PUT", payload);
    };
    Client2.prototype.updateListComment = function(list_id, payload) {
      return this.request("/lists/".concat(list_id, "/comment"), "PUT", payload);
    };
    Client2.prototype.updateListTweets = function(list_id, payload) {
      return this.request("/lists/".concat(list_id, "/tweets"), "PUT", payload);
    };
    Client2.prototype.updateListCooperators = function(list_id, payload) {
      return this.request("/lists/".concat(list_id, "/cooperators"), "PUT", payload);
    };
    Client2.prototype.updateListOptions = function(list_id, options) {
      return this.request("/lists/".concat(list_id, "/options"), "PUT", {
        options
      });
    };
    Client2.prototype.createListExport = function(list_id) {
      return this.request("/lists/".concat(list_id, "/export.zip"), "POST", null);
    };
    Client2.prototype.getListSubscriptions = function(list_id, offset, limit, email, premium) {
      if (email === void 0) {
        email = "";
      }
      if (premium === void 0) {
        premium = "";
      }
      var url = "/lists/".concat(list_id, "/subscriptions?offset=").concat(offset, "&limit=").concat(limit);
      if (email) {
        url += "&email=".concat(encodeURIComponent(email));
      }
      if (premium) {
        url += "&premium=".concat(premium);
      }
      return this.request(url, "GET", null);
    };
    Client2.prototype.getApikeys = function() {
      return this.request("/apikeys", "GET", null);
    };
    Client2.prototype.deleteApikey = function(id) {
      return this.request("/apikeys/".concat(id), "DELETE", null);
    };
    Client2.prototype.createApikey = function(name) {
      return this.request("/apikeys", "POST", {
        name
      });
    };
    Client2.prototype.searchPhotos = function(query, page, limit) {
      if (page === void 0) {
        page = 1;
      }
      if (limit === void 0) {
        limit = 10;
      }
      query = encodeURIComponent(query);
      return this.request("/composer/unsplash/photos/search?query=".concat(query, "&page=").concat(page, "&limit=").concat(limit), "GET", null);
    };
    Client2.prototype.getPhotoDownloadUrl = function(endpoint) {
      endpoint = encodeURIComponent(endpoint);
      return this.request("/composer/unsplash/photos/download_url?endpoint=".concat(endpoint), "GET", null);
    };
    Client2.prototype.createPost = function(listID, payload) {
      return this.request("/lists/".concat(listID, "/posts"), "POST", payload);
    };
    Client2.prototype.updatePost = function(listID, postID, payload) {
      return this.request("/lists/".concat(listID, "/posts/").concat(postID, "/update"), "PUT", payload);
    };
    Client2.prototype.updatePostOptions = function(listID, postID, options) {
      return this.request("/lists/".concat(listID, "/posts/").concat(postID, "/options"), "PUT", {
        options
      });
    };
    Client2.prototype.publishPost = function(listID, slug) {
      return this.request("/lists/".concat(listID, "/posts/").concat(slug, "/publish"), "PUT", null);
    };
    Client2.prototype.unpublishPost = function(listID, slug) {
      return this.request("/lists/".concat(listID, "/posts/").concat(slug, "/unpublish"), "PUT", null);
    };
    Client2.prototype.deliverPost = function(listID, slug, scheduledAt, channels) {
      if (channels === void 0) {
        channels = [];
      }
      var payload = {
        channels: []
      };
      if (scheduledAt) {
        payload.scheduled_at = scheduledAt;
      }
      if (channels) {
        payload.channels = channels;
      }
      return this.request("/lists/".concat(listID, "/posts/").concat(slug, "/deliver"), "PUT", payload);
    };
    Client2.prototype.createPostPreviewToken = function(listID, slug) {
      return this.request("/lists/".concat(listID, "/posts/").concat(slug, "/preview"), "POST", null);
    };
    Client2.prototype.getPostPreviewUrl = function(listID, slug, token) {
      return "".concat(this.apibase, "/lists/").concat(listID, "/posts/").concat(slug, "/preview?access_token=").concat(token);
    };
    Client2.prototype.uploadAttachment = function(formData, encrypted) {
      var appended = "";
      if (encrypted) {
        appended = "?encrypted=".concat(encrypted);
      }
      return this.requestFormData("/attachments".concat(appended), formData);
    };
    Client2.prototype.incCount = function(post_id, field) {
      return this.request("/posts/".concat(field, "?id=").concat(post_id), "POST", null);
    };
    Client2.prototype.getPostsOfMySubscriptions = function(offset, limit) {
      if (offset === void 0) {
        offset = 0;
      }
      if (limit === void 0) {
        limit = 16;
      }
      return this.request("/posts/subscribed?offset=".concat(offset, "&limit=").concat(limit), "GET", null);
    };
    Client2.prototype.getExploreTrendingPosts = function(offset, limit, lang) {
      if (offset === void 0) {
        offset = 0;
      }
      if (limit === void 0) {
        limit = 16;
      }
      if (lang === void 0) {
        lang = "";
      }
      var url = "/explore/trending/posts?offset=".concat(offset, "&limit=").concat(limit);
      if (lang) {
        url += "&lang=".concat(lang);
      }
      return this.request(url, "GET", null);
    };
    Client2.prototype.getExploreTrendingLists = function(offset, limit, lang) {
      if (offset === void 0) {
        offset = 0;
      }
      if (limit === void 0) {
        limit = 16;
      }
      if (lang === void 0) {
        lang = "";
      }
      var url = "/explore/trending/lists?offset=".concat(offset, "&limit=").concat(limit);
      if (lang) {
        url += "&lang=".concat(lang);
      }
      return this.request(url, "GET", null);
    };
    Client2.prototype.getComments = function(post_id, offset, limit) {
      if (offset === void 0) {
        offset = 0;
      }
      if (limit === void 0) {
        limit = 16;
      }
      return this.request("/comments?post_id=".concat(post_id, "&offset=").concat(offset, "&limit=").concat(limit), "GET", null);
    };
    Client2.prototype.getCommentsByList = function(list_id, offset, limit) {
      if (offset === void 0) {
        offset = 0;
      }
      if (limit === void 0) {
        limit = 16;
      }
      return this.request("/comments?list_id=".concat(list_id, "&offset=").concat(offset, "&limit=").concat(limit), "GET", null);
    };
    Client2.prototype.createComment = function(payload) {
      return this.request("/comments", "POST", payload);
    };
    Client2.prototype.deleteComment = function(comment_id) {
      return this.request("/comments/".concat(comment_id), "DELETE", null);
    };
    Client2.prototype.approveComment = function(comment_id) {
      return this.request("/comments/".concat(comment_id, "/approve"), "PUT", null);
    };
    Client2.prototype.rejectComment = function(comment_id) {
      return this.request("/comments/".concat(comment_id, "/reject"), "PUT", null);
    };
    Client2.prototype.getTweets = function(list_id, offset, limit, pub) {
      if (offset === void 0) {
        offset = 0;
      }
      if (limit === void 0) {
        limit = 16;
      }
      if (pub === void 0) {
        pub = false;
      }
      var url = "/tweets?list=".concat(list_id, "&offset=").concat(offset, "&limit=").concat(limit);
      if (pub) {
        url += "&public=1";
      }
      return this.request(url, "GET", null);
    };
    Client2.prototype.getTweet = function(tweet_id) {
      var url = "/tweets/".concat(tweet_id);
      return this.request(url, "GET", null);
    };
    Client2.prototype.getPinnedTweets = function(list_id) {
      return this.request("/tweets/pinned?list=".concat(list_id), "GET", null);
    };
    Client2.prototype.createTweet = function(list_id, payload) {
      return this.request("/tweets?list=".concat(list_id), "POST", payload);
    };
    Client2.prototype.updateTweet = function(tweet_id, payload) {
      return this.request("/tweets/".concat(tweet_id), "PUT", payload);
    };
    Client2.prototype.deleteTweet = function(tweet_id) {
      return this.request("/tweets/".concat(tweet_id), "DELETE", null);
    };
    Client2.prototype.reactTweet = function(tweet_id, payload) {
      return this.request("/tweets/".concat(tweet_id, "/reactions"), "POST", payload);
    };
    Client2.prototype.pinTweet = function(tweet_id) {
      return this.request("/tweets/".concat(tweet_id, "/pin"), "PUT", null);
    };
    Client2.prototype.unpinTweet = function(tweet_id) {
      return this.request("/tweets/".concat(tweet_id, "/unpin"), "DELETE", null);
    };
    Client2.prototype.setTweetPremium = function(tweet_id, premium) {
      return this.request("/tweets/".concat(tweet_id, "/premium"), "PUT", { premium });
    };
    Client2.prototype.setTweetNonPremium = function(tweet_id) {
      return this.request("/tweets/".concat(tweet_id, "/premium"), "DELETE", null);
    };
    Client2.prototype.getTweetReplies = function(tweet_id, offset, limit) {
      if (offset === void 0) {
        offset = 0;
      }
      if (limit === void 0) {
        limit = 16;
      }
      return this.request("/tweets/".concat(tweet_id, "/replies?offset=").concat(offset, "&limit=").concat(limit), "GET", null);
    };
    Client2.prototype.createTweetReply = function(payload) {
      return this.request("/tweets/".concat(payload.tweet_id, "/replies"), "POST", payload);
    };
    Client2.prototype.deleteTweetReply = function(tweet_id, reply_id) {
      return this.request("/tweets/".concat(tweet_id, "/replies/").concat(reply_id), "DELETE", null);
    };
    Client2.prototype.getListPacks = function(list_id) {
      return this.request("/lists/".concat(list_id, "/packs"), "GET", null);
    };
    Client2.prototype.getListPack = function(list_id, pack_id) {
      return this.request("/lists/".concat(list_id, "/packs/").concat(pack_id), "GET", null);
    };
    Client2.prototype.createListPack = function(list_id, payload) {
      return this.request("/lists/".concat(list_id, "/packs"), "POST", payload);
    };
    Client2.prototype.updateListPack = function(list_id, pack_id, payload) {
      return this.request("/lists/".concat(list_id, "/packs/").concat(pack_id), "PUT", payload);
    };
    Client2.prototype.deleteListPack = function(list_id, pack_id) {
      return this.request("/lists/".concat(list_id, "/packs/").concat(pack_id), "DELETE", null);
    };
    return Client2;
  }()
);
var AuxiliaClient = class {
  constructor(opts) {
    __publicField(this, "apibase", "");
    __publicField(this, "apikey", "");
    __publicField(this, "access_token", "");
    __publicField(this, "debug", false);
    this.apikey = opts.apikey || "";
    this.access_token = opts.access_token || "";
    this.apibase = opts.apibase || "https://api.quail.ink/auxilia";
    this.debug = opts.debug || false;
  }
  getAccessToken() {
    let token = this.access_token;
    if (token === "") {
      token = getAccessTokenFromEnv();
    }
    return token;
  }
  async request(url, method, body) {
    url = this.apibase + url;
    const headers = {
      "Content-Type": "application/json"
    };
    const token = this.getAccessToken();
    if (token) {
      headers["Authorization"] = `Bearer ${token}`;
    }
    if (this.apikey) {
      headers["X-QUAIL-KEY"] = this.apikey;
    }
    if (this.debug) {
      console.log(`request: ${method} ${url}`);
      console.log("- headers", headers);
      console.log("- body", body);
    }
    return sendRequest(url, method, headers, body);
  }
  async requestFormData(url, body) {
    url = this.apibase + url;
    const headers = {};
    const token = this.getAccessToken();
    if (token) {
      headers["Authorization"] = `Bearer ${token}`;
    }
    if (this.apikey) {
      headers["X-QUAIL-KEY"] = this.apikey;
    }
    if (this.debug) {
      console.log(`request: POST ${url}`);
      console.log("- headers", headers);
      console.log("- body", body);
    }
    return sendRequestFormData(url, headers, body);
  }
  getConfig() {
    return this.request(`/c`, "GET", null);
  }
  // place orders
  placeSubscriptionOrder(list_id, payload) {
    return this.request(`/orders/lists/${list_id}/upgrade`, "POST", payload);
  }
  // referrals
  getReferrerByCode(code) {
    return this.request(`/referrals/referrer?code=${code}`, "GET", null);
  }
  getMyReferralCode() {
    return this.request(`/referrals/code`, "GET", null);
  }
  // read orders
  getOrder(id) {
    const url = `/orders/${id}`;
    return this.request(url, "GET", null);
  }
  getMyOrders(offset, limit) {
    const url = `/orders/me?offset=${offset}&limit=${limit}`;
    return this.request(url, "GET", null);
  }
  getListOrders(list_id, offset, limit) {
    const url = `/orders/lists/${list_id}?offset=${offset}&limit=${limit}`;
    return this.request(url, "GET", null);
  }
  // subscriptions
  modSubscriptionMember(list_id, member_id, payload) {
    const url = `/subscriptions/${list_id}/members/${member_id}`;
    return this.request(url, "PUT", payload);
  }
  // List Incomes List
  getListIncomes(list_id, year) {
    const url = `/lists/${list_id}/incomes?year=${year}`;
    return this.request(url, "GET", null);
  }
  // Payments Settings
  getListPayments(list_id) {
    return this.request(`/lists/${list_id}/payments`, "GET", null);
  }
  // Referral
  updateListPaymentsReferral(list_id, payload) {
    return this.request(`/lists/${list_id}/payments/referral`, "PUT", payload);
  }
  // Crypto Payments
  updateListCryptoPayments(list_id, payload) {
    return this.request(`/lists/${list_id}/payments/crypto`, "PUT", payload);
  }
  // Fiat Payments
  updateListFiatPayments(list_id, payload) {
    return this.request(`/lists/${list_id}/payments/fiat`, "PUT", payload);
  }
  // Payouts
  getPayout() {
    return this.request(`/payouts`, "GET", null);
  }
  updatePayout(payload) {
    return this.request(`/payouts`, "PUT", payload);
  }
  // Payouts - Stripe
  connectToStripe(country) {
    return this.request(`/stripe/express?country=${country}`, "POST", null);
  }
  genStripeLoginURL() {
    return this.request(`/stripe/express/login`, "POST", null);
  }
  // Payouts - Crypto
  updateCryptoPayout(payload) {
    return this.request(`/payouts/crypto`, "PUT", payload);
  }
  // Payouts - Paypal
  // @TODO: remove
  updatePaypalPayout(payload) {
    return this.request(`/payouts/paypal`, "PUT", payload);
  }
  connectToPaypal(code) {
    return this.request(`/paypal/connect?code=${code}`, "POST", null);
  }
  disconnectToPaypal() {
    return this.request(`/paypal/connect`, "DELETE", null);
  }
  genPaypalLoginURL() {
    return this.request(`/paypal/connect/login`, "POST", null);
  }
  // Payouts - Wise
  updateWisePayout(payload) {
    return this.request(`/payouts/wise`, "PUT", payload);
  }
  registerEvm(network) {
    return this.request(`/payouts/evm/register?network=${network}`, "POST");
  }
  unregisterEvm(network) {
    return this.request(`/payouts/evm/unregister?network=${network}`, "POST");
  }
  // Payouts - Tax
  getTax() {
    return this.request(`/me/tax`, "GET", null);
  }
  submitTaxInfo(payload) {
    return this.request(`/me/tax`, "POST", payload);
  }
  uploadResidenceProof(formData) {
    return this.requestFormData(`/me/tax/proof`, formData);
  }
  // Payouts - Items
  getPayoutItems(year) {
    return this.request(`/payouts/items?year=${year}`, "GET", null);
  }
  // utils
  proxyToDiscord(pathname, query) {
    return this.request(`/proxy/discord?pathname=${pathname}&query=${encodeURIComponent(query)}`, "GET", null);
  }
  // Abuse Reports
  getAbuseReportOpponent(trace_id) {
    return this.request(`/reports/opponent?trace_id=${trace_id}`, "GET", null);
  }
  // crypto
  getCryptos() {
    return this.request(`/cryptos`, "GET", null);
  }
  getCrypto(symbol) {
    return this.request(`/cryptos/${symbol}`, "GET", null);
  }
  // currency
  getCurrencies() {
    return this.request(`/currencies`, "GET", null);
  }
  getCurrency(code) {
    return this.request(`/currencies/${code}`, "GET", null);
  }
  // country
  getCountries() {
    return this.request(`/countries`, "GET", null);
  }
  getCountryByAlpha2(code) {
    return this.request(`/countries/alpha-2/${code}`, "GET", null);
  }
  createAbuseReport(payload, ctoken) {
    return this.request(`/reports`, "POST", {
      "challenge-action": "abuse-report",
      "challenge-token": ctoken,
      ...payload
    });
  }
  getAbuseReportOpponent(trace_id) {
    return this.request(`/reports/opponent?trace_id=${trace_id}`, "GET", null);
  }
  createAbuseReport(payload, ctoken) {
    return this.request(`/reports`, "POST", {
      "challenge-action": "abuse-report",
      "challenge-token": ctoken,
      ...payload
    });
  }
  // ai
  generateFrontmatter(title, content, includes) {
    let url = `/composer/frontmatter`;
    if (includes.length > 0) {
      url = `${url}?includes=${includes.map((x) => encodeURIComponent(x.toLowerCase())).join(",")}`;
    }
    return this.request(url, "POST", {
      title,
      content
    });
  }
  generateMetadata(title, content, includes) {
    let url = `/composer/metadata`;
    if (includes.length > 0) {
      url = `${url}?includes=${includes.map((x) => encodeURIComponent(x.toLowerCase())).join(",")}`;
    }
    return this.request(url, "POST", {
      title,
      content
    });
  }
  generateTweets(title, content) {
    let url = `/composer/generate-tweets`;
    return this.request(url, "POST", {
      title,
      content
    });
  }
  createTask(taskType, payload) {
    let url = `/tasks/${taskType}`;
    return this.request(url, "POST", payload);
  }
  getTask(task_id) {
    let url = `/tasks/${task_id}`;
    return this.request(url, "GET", null);
  }
};

// src/oauth/oauth.js
var import_crypto = __toESM(require("crypto"));
var import_remote = require("@electron/remote");
var authBase = "https://quaily.com";
var apiBase = "https://api.quail.ink";
var clientID = "866c9dba-e267-47b8-ad48-2ca9105dd3cd";
var redirectURI = "http://localhost:63812/oauth/code";
var scopes = ["user.full", "post.write"];
function generateCodeVerifier() {
  const randomBytes = new Uint8Array(32);
  import_crypto.default.getRandomValues(randomBytes);
  let base64String = btoa(String.fromCharCode(...randomBytes)).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  return base64String;
}
function getCodeFromUrl(url) {
  const redirectUrl = new URL(url);
  const code = redirectUrl.searchParams.get("code");
  const returnedState = redirectUrl.searchParams.get("state") || "";
  if (code || returnedState) {
    return { code, returnedState };
  }
  return { code: "", returnedState: "" };
}
async function startLoginElectron() {
  const codeVerifier = generateCodeVerifier();
  const codeChallenge = codeVerifier;
  const state = import_crypto.default.randomUUID();
  const authURL = new URL("/oauth/authorize", authBase);
  authURL.searchParams.set("response_type", "code");
  authURL.searchParams.set("client_id", clientID);
  authURL.searchParams.set("redirect_uri", redirectURI);
  authURL.searchParams.set("scope", scopes.join(" "));
  authURL.searchParams.set("state", state);
  authURL.searchParams.set("code_challenge", codeChallenge);
  authURL.searchParams.set("code_challenge_method", "plain");
  const loginWindow = new import_remote.BrowserWindow({
    width: 600,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true
    }
  });
  const { session: { webRequest } } = loginWindow.webContents;
  const filter = {
    urls: [
      "http://localhost:63812/oauth/code*"
    ]
  };
  return new Promise((resolve, reject) => {
    const handleCallback = async (event, url) => {
      const { code, returnedState } = getCodeFromUrl(event, url, loginWindow);
      if (returnedState !== state) {
        throw new Error("State mismatch. Potential CSRF attack or lost session.");
      }
      if (!code) {
        throw new Error("No authorization code found in callback.");
      }
      loginWindow.close();
      const token = await exchangeCodeForToken(
        code,
        codeVerifier,
        redirectURI,
        clientID
      );
      return token;
    };
    loginWindow.webContents.on("will-navigate", (event, url) => {
      event.preventDefault();
      try {
        const token = handleCallback(url);
        resolve(token);
      } catch (err) {
        loginWindow.close();
        reject(err);
      }
    });
    loginWindow.webContents.on("did-redirect-navigation", (event, url, isInPlace, isMainFrame) => {
      event.preventDefault();
      try {
        const token = handleCallback(url);
        resolve(token);
      } catch (err) {
        loginWindow.close();
        reject(err);
      }
    });
    webRequest.onBeforeRequest(filter, async ({ url }) => {
      try {
        const token = handleCallback(url);
        resolve(token);
      } catch (err) {
        loginWindow.close();
        reject(err);
      }
    });
    loginWindow.loadURL(authURL.toString());
    loginWindow.on("closed", () => {
    });
  });
}
async function exchangeCodeForToken(code, verifier, redirectURI2) {
  const tokenURL = new URL("/oauth/token", apiBase);
  const bodyData = new URLSearchParams();
  bodyData.set("grant_type", "authorization_code");
  bodyData.set("code", code);
  bodyData.set("redirect_uri", redirectURI2);
  bodyData.set("client_id", clientID);
  bodyData.set("code_verifier", verifier);
  const response = await fetch(tokenURL.toString(), {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: bodyData
  });
  if (!response.ok) {
    const errorText = await response.text();
    throw new Error(`Token endpoint error: ${response.status} ${errorText}`);
  }
  return await response.json();
}
async function refreshToken(refreshToken2) {
  const tokenURL = new URL("/oauth/token", apiBase);
  const data = new URLSearchParams();
  data.set("grant_type", "refresh_token");
  data.set("refresh_token", refreshToken2);
  data.set("client_id", clientID);
  const resp = await fetch(tokenURL.toString(), {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: data
  });
  if (!resp.ok) {
    const errorText = await resp.text();
    throw new Error(`Refresh token error: ${resp.status} ${errorText}`);
  }
  return await resp.json();
}

// src/setting/index.ts
var import_obsidian11 = require("obsidian");

// manifest.json
var manifest_default = {
  id: "quail",
  name: "Quaily",
  version: "2.0.15",
  minAppVersion: "1.0.0",
  description: "Save, publish, delivery notes via Quaily.com as newsletters and blogs.",
  author: "Lyric",
  authorUrl: "https://quaily.com",
  isDesktopOnly: false
};

// src/setting/index.ts
init_modals();
init_i18n();
var QuailSettingTab = class extends import_obsidian11.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.showDebugCounter = 0;
    this.showDebugSection = false;
    this.plugin = plugin;
    this.app = app;
  }
  display() {
    var _a;
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h5", { text: "Quaily" });
    if (this.plugin.isLogged()) {
      new import_obsidian11.Setting(containerEl).setHeading().setName(t("settings.account.logged.title", { name: this.plugin.settings.me.name })).setDesc(t("settings.account.logged.desc", { email: this.plugin.settings.me.email })).addButton(
        (button) => button.setButtonText(t("common.logout")).setWarning().onClick(async () => {
          await this.plugin.clearTokens();
          this.display();
        })
      );
    } else {
      new import_obsidian11.Setting(containerEl).setHeading().setName(t("settings.account.need_to_login.title")).setDesc(t("settings.account.need_to_login.desc")).addButton(
        (button) => button.setCta().setButtonText(t("common.login")).onClick(async () => {
          await this.plugin.login();
          this.display();
        })
      );
    }
    const chSec = new import_obsidian11.Setting(containerEl).setName(t("settings.channel.title")).setDesc(t("settings.channel.desc"));
    if (((_a = this.plugin.settings.lists) == null ? void 0 : _a.length) !== 0) {
      chSec.addDropdown((dropdown) => {
        var _a2;
        if (((_a2 = this.plugin.settings.lists) == null ? void 0 : _a2.length) === 0) {
          dropdown.addOption("none", t("settings.channel.empty"));
        } else {
          for (let ix = 0; ix < this.plugin.settings.lists.length; ix++) {
            const list = this.plugin.settings.lists[ix];
            dropdown.addOption(list.id, list.title);
          }
        }
        dropdown.setValue(this.plugin.settings.listID);
        dropdown.onChange(async (value) => {
          var _a3;
          this.plugin.settings.listID = value;
          this.plugin.settings.listSlug = ((_a3 = this.plugin.settings.lists.find((list) => list.id === value)) == null ? void 0 : _a3.slug) || "";
          await this.plugin.saveSettings();
        });
      });
    } else {
      chSec.addButton(
        (button) => button.setCta().setButtonText(t("settings.channel.create")).onClick(async () => {
          window.open("https://quaily.com/dashboard", "_blank");
        })
      );
    }
    containerEl.createEl("h6", { text: t("settings.behavior") });
    new import_obsidian11.Setting(containerEl).setName(t("settings.behavior.use_english_cmds.title")).setDesc(t("settings.behavior.use_english_cmds.desc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.useEnglishCmds).onChange(async (value) => {
      this.plugin.settings.useEnglishCmds = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian11.Setting(containerEl).setName(t("settings.behavior.use_first_image_as_cover.title")).setDesc(t("settings.behavior.use_first_image_as_cover.desc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.useFirstImageAsCover).onChange(async (value) => {
      this.plugin.settings.useFirstImageAsCover = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h6", { text: t("settings.editor") });
    new import_obsidian11.Setting(containerEl).setName(t("settings.editor.strict_line_breaks.title")).setDesc(t("settings.editor.strict_line_breaks.desc")).addToggle((toggle) => toggle.setValue(this.plugin.settings.strictLineBreaks).onChange(async (value) => {
      this.plugin.settings.strictLineBreaks = value;
      await this.plugin.saveSettings();
    }));
    const version = containerEl.createDiv({
      cls: "setting-item"
    });
    version.innerText = `version: ${manifest_default.version}`;
    version.style.fontSize = "0.8em";
    version.style.width = "100%";
    version.style.textAlign = "left";
    version.style.color = "gray";
    version.onclick = () => {
      if (this.showDebugCounter === 4) {
        this.showDebugSection = !this.showDebugSection;
        this.showDebugCounter = 0;
        this.display();
      }
      this.showDebugCounter++;
    };
    if (this.showDebugSection) {
      containerEl.createEl("h6", { text: "Debug" });
      const textareaContainer = containerEl.createDiv({
        cls: "setting-item"
      });
      const textarea = textareaContainer.createEl("textarea", {
        cls: "setting-item-control",
        attr: { placeholder: "Enter your settings here...", disabled: "true" }
      });
      textarea.style.width = "100%";
      textarea.style.height = "200px";
      textarea.style.textAlign = "left";
      textarea.value = `list id: ${this.plugin.settings.listID}
list slug: ${this.plugin.settings.listSlug}
access token: ${this.plugin.settings.accessToken}
refresh token: ${this.plugin.settings.refreshToken}
token expiry: ${this.plugin.settings.tokenExpiry}`;
      const buttonsSec = new import_obsidian11.Setting(containerEl).setName("Dialog Test");
      buttonsSec.addButton(
        (button) => button.setButtonText("Publish").onClick(async () => {
          new PublishResultModal(this.app, null, {
            url: "https://quaily.com",
            title: "This is a test title",
            summary: "This is a test summary. The gray fox jumps over the lazy dog.",
            coverImageUrl: "https://quaily.com/portal-images/illustration/finance-you-0.webp"
          }).open();
        })
      );
      buttonsSec.addButton(
        (button) => button.setButtonText("Message").onClick(async () => {
          new MessageModal(this.app, { title: "Test", message: "This is a test message.", icon: "\u{1F916}", iconColor: "blue" }).open();
        })
      );
      buttonsSec.addButton(
        (button) => button.setButtonText("Loading").onClick(async () => {
          new LoadingModal(this.app).open();
        })
      );
      buttonsSec.addButton(
        (button) => button.setButtonText("Error").onClick(async () => {
          new ErrorModal(this.app, new Error("This is a test error.")).open();
        })
      );
      buttonsSec.addButton(
        (button) => button.setButtonText("expire token").onClick(async () => {
          this.plugin.settings.tokenExpiry = "2025-03-15T00:00:00Z";
          await this.plugin.saveSettings();
        })
      );
    }
  }
};
var setting_default = QuailSettingTab;

// main.ts
var DEFAULT_SETTINGS = {
  listID: "",
  listSlug: "",
  strictLineBreaks: true,
  useEnglishCmds: false,
  useFirstImageAsCover: false,
  // tokens
  accessToken: "",
  refreshToken: "",
  tokenExpiry: "",
  // user info
  me: null,
  lists: []
};
var QuailPlugin = class extends import_obsidian12.Plugin {
  async onload() {
    await this.loadSettings();
    await this.updateToken();
    this.getClients();
    if (this.isLogged()) {
      const q = [
        this.updateChannels(),
        this.updateMe()
      ];
      await Promise.all(q);
      await this.saveSettings();
    }
    await this.loadActions();
    this.addSettingTab(new setting_default(this.app, this));
  }
  onunload() {
  }
  getClients() {
    this.client = new Client({
      access_token: this.settings.accessToken,
      apibase: "https://api.quail.ink",
      debug: false
    });
    this.auxiliaClient = new AuxiliaClient({
      access_token: this.settings.accessToken,
      apibase: "https://api.quail.ink",
      debug: false
    });
  }
  async loadActions() {
    const actions = getActions(this);
    if (actions.length === 0) {
      console.error("quaily.loadActions: no actions found");
      return;
    } else if (actions.length === 1 && actions[0].id === "quail-login") {
      this.addCommand(actions[0]);
    } else {
      this.app.commands.removeCommand("quail-login");
      for (let ix = 0; ix < actions.length; ix++) {
        const action = actions[ix];
        this.addCommand(action);
      }
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async updateChannels() {
    const lists = await this.client.getUserLists(this.settings.me.id);
    this.settings.lists = lists;
    let found = false;
    for (let ix = 0; ix < lists.length; ix++) {
      const list = lists[ix];
      if (`${list.id}` === this.settings.listID || list.slug === this.settings.listSlug) {
        found = true;
        this.settings.listID = list.id;
        this.settings.listSlug = list.slug;
        break;
      }
    }
    if (!found) {
      if (lists.length > 0) {
        this.settings.listID = lists[0].id;
        this.settings.listSlug = lists[0].slug;
      } else {
        this.settings.listID = "";
        this.settings.listSlug = "";
      }
    }
  }
  async updateMe() {
    try {
      const me = await this.client.getMe();
      this.settings.me = me;
    } catch (err) {
      this.clearTokens();
      return;
    }
  }
  async login() {
    try {
      console.log("quaily.login: oauth flow start");
      const token = await startLoginElectron();
      console.log("quaily.login: token expiry:", token.expiry);
      this.settings.accessToken = token.access_token;
      this.settings.refreshToken = token.refresh_token;
      this.settings.tokenExpiry = token.expiry;
      this.getClients();
      const me = await this.client.getMe();
      this.settings.me = me;
      await this.updateChannels();
      await this.saveSettings();
      await this.loadActions();
    } catch (err) {
      console.error("quaily.login: oauth flow error:", err);
    }
  }
  async refreshToken() {
    try {
      console.log("quaily.refreshToken: refresh flow start");
      const token = await refreshToken(this.settings.refreshToken);
      console.log("quaily.refreshToken: access token expiry:", token.expiry);
      this.settings.accessToken = token.access_token;
      this.settings.refreshToken = token.refresh_token;
      this.settings.tokenExpiry = token.expiry;
      await this.saveSettings();
    } catch (err) {
      console.error("quaily.refreshToken: refresh token flow error:", err);
    }
  }
  async clearTokens() {
    console.log("quaily.clearTokens: clear tokens");
    this.settings.accessToken = "";
    this.settings.refreshToken = "";
    this.settings.tokenExpiry = "";
    await this.saveSettings();
    await this.loadActions();
  }
  isLogged() {
    var _a;
    if (this.settings.accessToken === "" || this.settings.refreshToken === "" || this.settings.tokenExpiry === "" || this.settings.me === null || ((_a = this.settings.lists) == null ? void 0 : _a.length) === 0) {
      return false;
    }
    return true;
  }
  updateToken() {
    if (this.settings.tokenExpiry !== "") {
      const expiry = new Date(this.settings.tokenExpiry);
      const now = new Date();
      const refreshTokenThreshold = 3600 * 24 * 364 * 1e3;
      const accessTokenThreshold = 3600 * 12 * 1e3;
      if (expiry.getTime() <= now.getTime() - refreshTokenThreshold) {
        console.log("quaily.updateToken: token expired, clear tokens", expiry, now);
        this.clearTokens();
      } else if (expiry.getTime() <= now.getTime() - accessTokenThreshold) {
        console.log("quaily.updateToken: token expired, refresh token", expiry, now);
        this.refreshToken();
      } else {
        this.refreshToken();
        console.log("quaily.updateToken: token is still valid, nothing to do");
      }
    } else {
      console.log("quaily.updateToken: no token found, clear tokens");
      this.clearTokens();
    }
  }
};

/* nosourcemap */